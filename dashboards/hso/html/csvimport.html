<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.plot.ly/plotly-3.3.0.min.js" charset="utf-8"></script>
<script type="text/javascript"
	src="../../../src/js/water/structures/WaterLevelCsvReader.js"
	charset="utf-8"></script>
<title>Read CSV File</title>
<style>
.line {
	display: flex;
	flex-direction: row;
}

.value {
	margin-right: 5px;
	background: red;
	width: 150px;
}

.value:first-child {
	width: 200px;
}
</style>
</head>
<body>
	<div>
		<label>Start Date</label> <input type="date" id="startDate"
			name="Series start date" value="2021-03-21" /> <label>End
			Date</label> <input type="date" id="endDate" name="Series end date"
			value="2021-03-28" /> <label>Weir name: </label> <input type='text'
			id="nameField" value="WS000278" />
	</div>
	<div>
		<input type="file" id="fileInput" accept=".csv" />
	</div>

	<pre id="output"></pre>

	<script>
	

		class DialogPane{

			constructor(parent) {

				this.dialogPane = document.createElement("div");
				this.dialogPane.style = 'position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; background-color: rgba(200, 200, 200, 0.6); display: none';
				parent.appendChild(this.dialogPane);
				
				this.centerDialog = document.createElement("div");
				this.dialogPane.appendChild(this.centerDialog);

				this.centerDialog.style.position='fixed';
				this.centerDialog.style.top='50%';
				this.centerDialog.style.left= '50%';
				this.centerDialog.style.transform='translate(-50%, -50%)';
				
				this.infoText = document.createElement("p");
				this.centerDialog.appendChild(this.infoText);
				
				this.yesButton = document.createElement("button");
				this.yesButton.innerHTML = "Yes";
				this.yesButton.style.display = 'none';
				this.centerDialog.appendChild(this.yesButton);
				this.noButton = document.createElement("button");
				this.noButton.innerHTML = "No";
				this.noButton.style.display = 'none';
				this.centerDialog.appendChild(this.noButton);
			}
			
			show(){
				this.dialogPane.style.display = 'inherit';	
			}
			
			hide(){
				this.dialogPane.style.display = 'none';
			}
			
			setInfoText(text){
				this.infoText.innerHTML = text;
			}
			
			confirmClose(text, event){
				this.setInfoText(text);
				this.yesButton.innerHTML = "Close";
				this.yesButton.style.display = "inline";
				this.noButton.style.display = 'none';
				let self = this;
				this.yesButton.onclick= (e)=>{
					self.hide();
					if(event!= null){
						event(e);
					}
				};
			}
			
			yesNo(text, yesEvent, noEvent){
				this.setInfoText(text);
				this.yesButton.innerHTML = "Yes";
				this.yesButton.style.display = "inline";
				this.noButton.innerHTML = "No";
				this.noButton.style.display = 'inline';
				let self = this;
				
				this.yesButton.onclick= (e)=>{
					self.hide();
					if(yesEvent!= null){
						yesEvent(e);
					}
				};
				this.noButton.onclick= (e)=>{
					self.hide();
					if(noEvent!= null){
						noEvent(e);
					}
				};
			}
		}
		
		var importPanel = null;
		
		function getWaterLevelTraces(results) {
			let traces = [];

			if (results == null || results.length < 2) {
				return traces;
			}

			let headers = results[0];
			let attributes = results[1];
			for (let i = 0; i < headers.length && i < attributes.length; i++) {
				if (headers[i] == null || headers[i].length == 0
						|| headers[i].endsWith("quality")) {
					continue;
				}

				let trace = {
					x : [],
					y : [],
					mode : 'lines+markers',
					name : headers[i] + " " + attributes[i],
					myHeader: headers[i],
					myAttribute: attributes[i],
				};
				traces.push(trace);

				for (let r = 0; r < results.length; r++) {
					if (results[r][i + 1] == "original reliable") {
						trace.x.push(new Date(results[r][0]));

						let value = parseFloat(results[r][i].replace(",", "."));
						trace.y.push(value);
					}
				}

			}
			return traces;
		}
		
		let weirs = [{id:312, name:'WS000278'}];
		
		function storeTraces(weirs, traces){

			for(let trace of traces){
				
				for(let weir of weirs){
					
					if(trace.myHeader != weir.name){
						continue;
					}
						
					console.log('Map trace values for weir ' + weir.name + " with id " + weir.id);
					const startDate = new Date(document.getElementById('startDate').value);
					const startDateMS = startDate.getTime();
					let valuesArray= [trace.x.length*2];
					for(let i = 0; i < trace.x.length; i++){
						let relativeMS = trace.x[i].getTime() - startDateMS;
						valuesArray[2*i]=relativeMS;
						valuesArray[2*i+1]=trace.y[i];
					}
						
					if(weir.customTraces == null){
						weir.customTraces = new Map();						
					} 
					weir.customTraces.set(trace.myAttribute, valuesArray);
				}
			}
			
			for(let weir of weirs){
				console.log("Weir "+ weir.name);
				if(weir.customTraces == null){
					continue;
				}
				for(let [k,v] of weir.customTraces ){
					console.log(k + " : " + v);
				}
			}
		}
		
		function plotResults(reader) {

			
			
			let results = reader.getResults();
			if(results == null || results.length == 0){
				if(importPanel!= null){
					importPanel.confirmClose("No matches found for Weirs");
				}
				return;
			}
			
			if(results.length == 1 && results[0].length == 0 || results[0].length == 1 && results[0][0]==''){
				importPanel.confirmClose("No matches found for Weir names");
				return;
			}
					
			let traces = getWaterLevelTraces(results);
			if(traces.length == 0){
				importPanel.confirmClose(results[0].length +" matches found, but no traces made for start and end time.")
				return;
			}
			
			importPanel.yesNo(results[0].length +" matches found, "+ traces.length+ " traces made for start and end time.<br>Do you want to save these traces to your project?", (e)=>{
				storeTraces(weirs, traces);
			}, null);

			let layout = {
				title : {
					text : 'Data values'
				}
			};
			
			document.getElementById("output").style.display = 'block';
			Plotly.newPlot('output', traces, layout);
		}

		let validNames = document.getElementById("nameField").value.split(",");
		function isValidHeader(header) {
			if (header == null || header.endsWith("comments")) {
				return false;
			}

			let names = validNames;
			for(name of names){
				if(header.startsWith(name)){
					return true;
				}
			}
			return false;
		}
		
		

		
		const reader = new WaterLevelCSVReader();
		reader.setHeaderPredicate(isValidHeader);
		reader.setOnFinish(plotResults);

		document.getElementById('fileInput').addEventListener('change',
				function(event) {

			document.getElementById("output").style.display = 'none';
			importPanel = new DialogPane(document.body);
			
			
			
					validNames = document.getElementById("nameField").value.split(",");
					const file = event.target.files[0];
					if (file) {
						importPanel.setInfoText(`Importing ${file.name} ... please wait.`);
						importPanel.show();
						const startDate = new Date(document.getElementById('startDate').value);
						const endDate = new Date(document.getElementById('endDate').value);
						reader.setStartDate(startDate);
						reader.setEndDate(endDate);
					
						reader.readFromFile(file);
					}
				});
	</script>
</body>
</html>