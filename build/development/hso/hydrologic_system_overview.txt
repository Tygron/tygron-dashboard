
	<style>
@charset "UTF-8";

:root {
	--tygron-white: rgba(245, 245, 245, 1.0);
	--tygron-blue: rgb(10, 173, 207);
}

html, body {
	padding: 5px;
	background-color: white;
	font-family: sans-serif;
}

/* Style the button that is used to open and close the collapsible content */
.collapsible {
	background-color: #eee;
	color: #444;
	cursor: pointer;
	padding: 18px;
	width: 100%;
	border: none;
	text-align: left;
	outline: none;
	font-size: 15px;
}

/* Style the collapsible content. Note: hidden by default */
.content {
	padding: 0 0.25em;
	background-color: white;
	overflow: hidden;
}

.content.direct {
	padding: 0 0em;
}

.content .delayed {
	max-height: 0;
	transition: max-height 0.2s ease-out;
}

.collapsible:after {
	content: '\02795';
	/* Unicode character for "plus" sign (+) */
	font-size: 13px;
	color: white;
	float: right;
	margin-left: 5px;
}

/**
.active .collapsible {
	font-weight: bold;
	font-size: 1.5em;
}

.active .collapsible:hover {
	background-color: cornflowerblue;
	color: white;
}
.active:after {
	content: "\2796";	
}
*/
.datatable thead {
	font-weight: bold;
}

.datatable {
	height: 1px;
	border-collapse: collapse;
	width: 100%;
	table-layout: auto;
	font-family: Arial;
	font-size: 0.9em;
}

.datatable tr {
	/*border-bottom: 1px solid black;*/
	height: 100%;
}

.datatable tr:nth-child(even) {
	background-color: rgb(240, 240, 240)
}

.datatable td {
	height: 100%;
}

.datatable td>div {
	margin: 0.25em;
	padding: 0.25em 0.25em 0.25em 0.25em;
	position: relative;
	border-radius: 0.5em;
}

.timeframe-slider {
	--primaryColor: #0366D6;
	--value-active-color: white;
	--value-background: var(--primaryColor);
	--value-font: 700 12px/1 Arial;
	--progress-color: #EEE;
	--progress-shadow: 2px 2px 4px rgba(0, 0, 0, .1) inset;
	--fill-color: var(--primaryColor);
	--thumb-size: 16px;
	--track-height: calc(var(--thumb-size)/2);
	--thumb-shadow: 0 0 3px rgba(0, 0, 0, .2);
	--ticks-thickness: 1px;
	--ticks-height: 5px;
	--ticks-color: silver;
	--step: 1;
	--ticks-count: (var(--max)- var(--min))/var(--step);
	--maxTicksAllowed: 30;
	--too-many-ticks: Min(1, Max(var(--ticks-count)- var(--maxTicksAllowed),
		0));
	--x-step: Max(var(--step), var(--too-many-ticks)* (var(--max)- var(--min)));
	/* manipulate the number of steps if too many ticks exist, so there would only be 2*/
	--tickInterval: 100/((var(--max)- var(--min))/var(--step))* var(--tickEvery, 1);
	--tickIntervalPerc: calc(( 100% - var(--thumb-size))/( (var(--max)- var(--min))/var(--x-step))*
		
		
		 var(--tickEvery, 1));
	--completed: calc(( var(--value)- var(--min))/(var(--max)- var(--min))*
		 100);
}

.timeframe-slider {
	display: inline-block;
	height: var(--thumb-size);
	margin: 0;
	background: linear-gradient(to right, var(--ticks-color)
		var(--ticks-thickness), transparent 1px) repeat-x;
	background-size: var(--tickIntervalPerc) var(--ticks-height);
	background-position: calc(var(--thumb-size)/2) bottom;
	padding-bottom: var(--ticks-height);
	position: relative;
	width: 100%;
}

.timeframe-slider::before, .timeframe-slider::after {
	font: 12px Arial;
	content: counter(x);
	position: absolute;
	bottom: -2.5ch;
}

.timeframe-slider::before {
	counter-reset: x var(--min);
	left: 0;
}

.timeframe-slider::after {
	counter-reset: x var(--max);
	right: 0;
}

.timeframe-slider__progress {
	position: absolute;
	left: 0;
	top: calc(50% - var(--ticks-height)/2);
	transform: translateY(-50%);
	width: 100%;
	height: calc(var(--track-height));
	pointer-events: none;
	z-index: -1;
	box-shadow: var(--progress-shadow);
	border-radius: 20px;
	background: var(--fill-color, white);
}

.timeframe-slider__progress::before {
	content: '';
	display: block;
	margin-left: auto;
	margin-right: -.5px;
	width: calc(100% - var(--completed)* 1%);
	height: 100%;
	background: var(--progress-color, #EEE);
	box-shadow: inherit;
	border-radius: 0 20px 20px 0;
}

.timeframe-slider>input {
	width: 100%;
	height: var(--thumb-size);
	/* margin: 0 calc(var(--thumb-size)/-2);*/
	margin: 0;
	cursor: -webkit-grab;
	cursor: grab;
	outline: none;
}

.timeframe-slider thumb {
	appearance: none;
	height: var(--thumb-size);
	width: var(--thumb-size);
	border-radius: 50%;
	background: var(--thumb-color, white);
	border: 1px solid silver;
	/*box-shadow: var(--inner-shadow, 0 0), var(--thumb-shadow);*/
}

.timeframe-slider>input::-webkit-slider-thumb {
	appearance: none;
	height: var(--thumb-size);
	width: var(--thumb-size);
	border-radius: 50%;
	background: var(--thumb-color, white);
	border: 1px solid silver;
	/*box-shadow: var(--inner-shadow, 0 0), var(--thumb-shadow);*/
}

.timeframe-slider>input::-moz-slider-thumb {
	appearance: none;
	height: var(--thumb-size);
	width: var(--thumb-size);
	border-radius: 50%;
	background: var(--thumb-color, white);
	border: 1px solid silver;
	/*box-shadow: var(--inner-shadow, 0 0), var(--thumb-shadow);*/
}

.timeframe-slider>input::-ms-thumb {
	appearance: none;
	height: var(--thumb-size);
	width: var(--thumb-size);
	border-radius: 50%;
	background: var(--thumb-color, white);
	border: 1px solid silver;
	/*box-shadow: var(--inner-shadow, 0 0), var(--thumb-shadow);*/
}

.timeframe-slider>input:active {
	cursor: grabbing;
}

.timeframe-slider>input:active+output {
	transition: 0s;
}

.timeframe-slider>input:hover+output {
	background: transparent;
	transform: translate(var(--x-offset), 3px);
}

.timeframe-slider>output {
	--x-offset: calc(var(--completed)* -1%);
	pointer-events: none;
	position: absolute;
	background: transparent;
	border-radius: 10px;
	padding: 0 4px;
	top: -3ch; /* calc(Max(var(--thumb-size), var(--track-height)) * -1);*/
	left: calc(var(--completed)* 1%);
	transform: translate(var(--x-offset), 6px);
	transition: all .12s ease-out, left 0s, top 0s;
}

.timeframe-slider>output::after {
	content: var(--text-value);
	font: var(--value-font);
}

.water-structure-sidebar {
	flex: 1;
}

.water-structure-sidebar>.vertical-menu {
	width: 200px;
	height: 75vh;
	overflow-y: auto;
	margin-right: 1em;
	padding-right: 1em;
}

.water-structure-sidebar>.vertical-menu a {
	background-color: #eee;
	color: black;
	display: block;
	padding: 12px;
	text-decoration: none;
	cursor: default;
	border-radius: 5px;
	margin-bottom: 3px;
	font-size: 12px;
}

.water-structure-sidebar>.vertical-menu a:hover {
	background-color: #ccc;
}

.water-structure-sidebar>.vertical-menu a.selected {
	background-color: orange;
	color: black;
}

.water-structure-main {
	display: flex;
	flex-direction: row;
}

.water-structure-info-row, .water-structure-info-row-spread {
	display: flex;
	flex-wrap: wrap;
	flex-direction: row;
}

.water-structure-info-row-spread {
	justify-content: space-between;
}

.water-structure-info-column {
	display: flex;
	flex-wrap: wrap;
	flex-direction: column;
}

.water-structure-info-grid {
	display: grid;
	grid-template-columns: minmax(80px, auto) 1fr;
	column-gap: 1em;
}

.water-structure-plot {
	max-width: fit-content;
}

.water-structure-detail {
	flex: 3;
}
/*Hydologic System Overview override css here*/
.column {
	height: 100%;
	max-height: auto;
	overflow-x: scroll;
	border: 1px solid grey;
	border-radius: 20px;
	box-shadow: 2px 2px 10px #c1c1c1;
	font-family: Arial;
	padding: 30px;
	margin: 10px;
}

.grid {
	display: grid;
	grid-template-columns: 50% auto;
	/*grid-template-rows: 45% auto;*/
	width: 100%;
	height: 100%;
	gap: 25px;
}

.flex-container {
	display: flex;
	flex-direction: column;
	justify-content: center;
}

.slider-background {
	margin: 1em;
	width: 95%;
	height: 15px;
}

header {
	padding: 14px 18px;
	border: 2px black;
	border-radius: 15px;
	background: rgb(45, 45, 45);
	box-shadow: 0px 0px 10px rgba(0, 0, 0, .15);
}

header h1 {
	margin: 0;
	font-size: 18px;
	letter-spacing: .2px
}

header .sub {
	color: white;
	font-size: 12px;
	margin-top: 4px
}

.layout {
	display: grid;
	grid-template-columns: 240px 1fr;
	min-height: calc(100vh - 60px);
}

.sidebar {
	background: white;
	border-radius: 15px;
	padding: 10px 0px ;
	margin-top: 15px;
	overflow-y: auto;
	box-shadow: 0px 0px 10px rgba(0, 0, 0, .15);
}

.sidebar h3 {
	font-size: 13px;
	font-family: sans-serif;
	margin: 10px 16px 4px;
	color: black;
	text-transform: uppercase;
}

.nav-group {
	margin-bottom: 6px;
}

.nav-item {
	cursor: pointer;
	padding: 8px 16px;
	color: black;
	font-size: 13px;
	font-family: sans-serif;
	display: flex;
	justify-content: space-between;
	align-items: center;
	transition: background .15s;
}

.nav-item:hover {
	background: rgb(222, 222, 222);
}

.nav-item span::after{
	content: '▸';
}

.nav-item.open span::after{
	content: '▾';
}

.subnav {
	display: none;
	flex-direction: column;
}

.subnav.open {
	display: flex;
}

.sub-item {
	padding: 7px 28px;
	font-size: 12px;
	font-family: sans-serif;
	cursor: pointer;
	color: rgb(40,40,40);
	transition: background .15s;
}

.sub-item:hover {
	background: rgb(222, 222, 222);
}

.sub-item.active {
	background:orange;
	color: black;
	border-left: 3px solid black;
	font-family: sans-serif;
	font-size:12px;
}

main {	
	padding: 16px;
}

.card {
	background: white;
	border-radius: 14px;
	padding: 12px 14px;
	box-shadow: 0px 0px 10px rgba(0, 0, 0, .15);
	margin-bottom: 12px;
}

h2 {
	font-size: 15px;
	font-family: sans-serif;
	color: black;
}

header h2 {
	margin: 0 0 8px;
	color: white;
}

.section {
	display: none;
}

.section.active {
	display: block;
}

.section>iframe {
	width: 100%;	
	height: calc(100vh - 130px);	
	border: 1px solid black;
	border-radius: 12px;
	background: salmon;
}

table {
	width: 100%;
	border-collapse: collapse;
	font-size: 13px;
	margin-top: 8px;
}

th, td {
	padding: 6px 8px;
	border-bottom: 1px solid black;
	text-align: left;
}

tr:hover td {
	background:rgb(222, 222, 222);
}

tr.selected td {
	background: sandybrown
}

canvas {
	background: lavender;
	border: 1px solid black;
	width: 100%;
}

.btn {
	appearance: none;
	border: 1px solid black;
	background: rgb(222, 222, 222);
	color: black;
	padding: 6px 10px;
	border-radius: 8px;
	cursor: pointer;
	font-size: 13px;
	margin-top: 4px;
}

.btn:hover {
	border-color: black;
}

.btn:active {
	transform: translateY(1px);
}

#wb-sankeyplot .card{
	display:flex;
	flex-direction: column;
	height:100%;
}

#wb-sankeyplot{	
	height:85vh;
} 
#sankeyPlot{	
	height:100%;
}

</style>
	<header>
		<h2>Hydrologic System Overview</h2>
		<div id="waterAreaName" class="sub"
			style="font-size: 14px; margin-top: 6px;">Water Management Area
			Name Here</div>
		<div class="sub">Overview of water balance, culverts, weirs,
			results and formulas.</div>
	</header>
	<div class="layout">

		<!-- SIDEBAR -->
		<aside class="sidebar">

			<h3>Water Balance</h3>
			<div id="navGroupWaterBalance" class="nav-group">
				<div class="nav-item" data-target="wb-group">
					Water Balance <span></span>
				</div>
				<div class="subnav" id="wb-group">
					<div class="sub-item active" data-section="wb-volumetabel">Water
						Balance Table</div>
					<div class="sub-item" data-section="wb-volumeplot">Volume
						Plot</div>
					<div class="sub-item" data-section="wb-flowtabel">Flow Table</div>
					<div class="sub-item" data-section="wb-sankeyplot">Sankey
						Diagram</div>
				</div>
			</div>

			<h3>Structures</h3>

			<!-- Culverts -->
			<div id="navGroupCulverts" class="nav-group">
				<div class="nav-item" data-target="duikers-group">
					Culverts <span></span>
				</div>
				<div class="subnav" id="duikers-group">
					<div class="sub-item" data-section="kw-duikers-parameters">Parameters</div>
					<div class="sub-item" data-section="kw-duikers-uitkomsten">Results</div>
					<div class="sub-item" data-section="kw-duikers-detail">Detail</div>
					<div class="sub-item" data-section="kw-duikers-formule">Formula</div>
				</div>
			</div>

			<!-- Weirs -->
			<div id="navGroupWeirs" class="nav-group">
				<div class="nav-item" data-target="stuwen-group">
					Weirs <span></span>
				</div>
				<div class="subnav" id="stuwen-group">
					<div class="sub-item" data-section="kw-stuwen-parameters">Parameters</div>
					<div class="sub-item" data-section="kw-stuwen-uitkomsten">Results</div>
					<div class="sub-item" data-section="kw-stuwen-detail">Detail</div>
					<div class="sub-item" data-section="kw-stuwen-formule">Formula</div>
				</div>
			</div>

		</aside>

		<!-- MAIN CONTENT -->
		<main>

			<!-- WATER BALANCE TABLE -->
			<section class="section active" id="wb-volumetabel">
				<div class="card">
					<h2>Water Balance Table</h2>
					<button class="btn" id="balanceCSVButton">Download CSV</button>
					<table id="waterBalanceTable" class="datatable"></table>
				</div>
			</section>

			<!-- WATER VOLUME PLOT -->
			<section class="section" id="wb-volumeplot">
				<div class="card">
					<h2>Water Balance Plot</h2>
					<div id="balanceSliderDiv"></div>
					<div id="balancePlot" /></div>
				</div>
			</section>
			<!-- WATER FLOW TABLE -->
			<section class="section active" id="wb-flowtabel">
				<div class="card">
					<h2>Water Flow Table</h2>
					<button class="btn" id="flowCSVButton">Download CSV</button>
					<table id="waterFlowTable" class="datatable"></table>
				</div>
			</section>

			<!-- WATER SANKEY PLOT -->
			<section class="section" id="wb-sankeyplot">
				<div class="card">
					<h2>Water Flow Sankey Diagram</h2>
					<div id="sankeySliderDiv"></div>
					<div id="sankeyPlot"></div>
				</div>
			</section>

			<!-- CULVERT PAGES -->
			<section class="section" id="kw-duikers-parameters">
				<div class="card">
					<h2>Culvert Parameters</h2>
					<div id="culvertParamSliderDiv"></div>
					<button class="btn" id="culvertDownloadParamCsvButton">Download
						CSV</button>

					<table id="culvertParamTable">
						<thead>
							<tr>
								<th>ID</th>
								<th>Name</th>
								<th>Diameter (m)</th>
								<th>Invert (m+NAP)</th>
								<th>Material</th>
							</tr>
						</thead>
						<tbody></tbody>
					</table>
				</div>
			</section>
			<section class="section" id="kw-duikers-uitkomsten">
				<div class="card">
					<h2>Culvert Results</h2>
					<div id="culvertResultSliderDiv"></div>
					<button class="btn" id="culvertDownloadResultCsvButton">Download
						CSV</button>
					<button class="btn" id="culvertImportResultCsvButton">Import
						CSV</button>

					<table id="culvertResultsTable">
						<thead>
							<tr>
								<th>ID</th>
								<th>Name</th>
								<th>Q max (m³/s)</th>
								<th>H max (m+NAP)</th>
								<th>Status</th>
							</tr>
						</thead>
						<tbody></tbody>
					</table>
				</div>
			</section>

			<section class="section" id="kw-duikers-detail">
				<div class="card">
					<h2>Culvert Detail</h2>
					<div class="water-structure-main">
						<aside class="water-structure-sidebar">
							<h3>Culverts list:</h3>
							<div id="culvertList" class="vertical-menu">
								<a class="selected">Duiker 1</a> <a>Duiker 2</a><a>Nieuwe
									Duiker</a>
							</div>
						</aside>
						<section id="culvertDetailParent" class="water-structure-detail"></section>
					</div>
				</div>
			</section>

			<section class="section" id="kw-duikers-formule">
				<iframe
					src="https://support.tygron.com/wiki/Culvert_formula_(Water_Overlay)"></iframe>
			</section>

			<!-- WEIR PAGES -->
			<section class="section" id="kw-stuwen-parameters">
				<div class="card">
					<h2>Weir Parameters</h2>
					<div id="weirParamSliderDiv"></div>
					<button class="btn" id="weirDownloadParamCsvButton">Download
						CSV</button>

					<!-- WEIR PARAMETERS TABLE -->
					<table id="weirParamTable">
						<thead>
							<tr>
								<th>ID</th>
								<th>Name</th>
								<th>Coefficient</th>
								<th>Height (m)</th>
								<th>Width (m)</th>
								<th>Angle (°)</th>
								<th>Target Level (m)</th>
								<th>Warnings</th>
							</tr>
						</thead>
						<tbody></tbody>
					</table>

				</div>
			</section>


			<section class="section" id="kw-stuwen-uitkomsten">
				<div class="card">
					<h2>Weir Results</h2>
					<div id="weirResultSliderDiv"></div>
					<button class="btn" id="weirDownloadResultCsvButton">Download
						CSV</button>
					<button class="btn" id="weirImportResultCsvButton">Import
						CSV</button>
					<table id="weirResultsTable">
						<thead>
							<tr>
								<th>Scenario</th>
								<th>Name</th>
								<th>ID</th>
								<th>Flow</th>
								<th>Height</th>
								<th>Datum A</th>
								<th>Datum B</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Scenario</td>
								<td>Weir 1</td>
								<td>1</td>
								<td>0.1</td>
								<td>0.5</td>
								<td>0.6</td>
								<td>0.35</td>
							</tr>
							<tr>
								<td>Scenario</td>
								<td>Weir 2</td>
								<td>2</td>
								<td>-0.2</td>
								<td>0.4</td>
								<td>0.3</td>
								<td>0.75</td>
							</tr>
						</tbody>
					</table>

				</div>
			</section>


			<section class="section" id="kw-stuwen-detail">
				<div class="card">
					<h2>Weir Detail</h2>
					<div class="water-structure-main">
						<aside class="water-structure-sidebar">
							<h3>Weirs list:</h3>
							<div id="weirList" class="vertical-menu">
								<a class="selected">Stuw 1</a> <a>Stuw 2</a><a>Nieuwe stuw</a>
							</div>
						</aside>
						<section id="weirDetailParent" class="water-structure-detail"></section>
					</div>
				</div>
			</section>

			<section class="section" id="kw-stuwen-formule">
				<iframe
					src="https://support.tygron.com/wiki/Weir_formula_(Water_Overlay)"></iframe>
			</section>

		</main>
	</div>
	<script>
		
/**
 * @param {Array.<string>} properties Array of Property names to set into data
 * @returns {Object} Data Object containing the properties.
 */
function createLinks(properties) {

	return { properties: properties };
}

/**
 * @param {Object} data object with String properties, initialized using createLinks method 
 * @param {int} timeframe timeframe index at which the link should be 
 * @return {Object} containing a source, target and value array properties.
 */
function getLink(data, timeframe) {

	if (!Array.isArray(data.timeframeLinks)) {
		data.timeframeLinks = [];
	}

	while (data.timeframeLinks.length - 1 < timeframe) {
		data.timeframeLinks.push({
			source: [],
			target: [],
			value: [],
		});
	}

	return data.timeframeLinks[timeframe];
}

/**
 * @param {Object} data object with String properties, initialized using createLinks method 
 * @param {int} timeframe timeframe index at which the link should be set
 * @param {String} from the property from which an ammount is removed.
 * @param {String} to the property to which an amount is added.
 * @param {Number} amount that is moved between the two properties
 */
function addLink(data, timeframe, from, to, amount) {

	let link = getLink(data, timeframe)
	if (!Array.isArray(link.source)) {
		link.source = [];
	}
	if (!Array.isArray(link.target)) {
		link.target = [];
	}
	if (!Array.isArray(link.value)) {
		link.value = [];
	}

	link.source.push(data.properties.indexOf(from));
	link.target.push(data.properties.indexOf(to));
	link.value.push(amount);
}


function createTimeframeData(timeframes, itemID, properties) {

	let data = {
		itemID: itemID,
		timeframes: timeframes
	};

	for (let i = 0; i < properties.length; i++) {
		data[properties[i]] = [];
		for (let j = 0; j < timeframes; j++) {
			data[properties[i]].push(0);
		}
	}

	return data;
}

/**
 * Unused function, soon te be removed!!!
 */
function setTimeframeValue(data, property, value) {

	for (let i = 0; i < data.dataframes.length; i++) {

		data[property][i] = value;
	}
}

function addFlowValues(data, timeframe, propertyFrom, propertyTo, propertyAreaIDFrom, propertAreaIDTo, values, condition = undefined) {
	addFlowValuesWithInner(data, timeframe, propertyFrom, propertyTo, undefined, propertyAreaIDFrom, propertAreaIDTo, values, condition);
}

function addFlowValuesWithInner(data, timeframe, propertyFrom, propertyTo, propertyInner, propertyAreaIDFrom, propertAreaIDTo, values, condition = undefined) {

	if (data[propertyFrom][timeframe] == undefined) {
		data[propertyFrom][timeframe] = 0;
	}

	if (data[propertyTo][timeframe] == undefined) {
		data[propertyTo][timeframe] = 0;
	}

	if (propertyInner != undefined) {
		if (data[propertyInner][timeframe] == undefined) {
			data[propertyInner][timeframe] = 0;
		}
	}

	for (let i = 0; i < values.length && i < data[propertyAreaIDFrom].length && i < data[propertAreaIDTo].length; i++) {

		if (propertyInner != undefined && (data[propertAreaIDTo][i] == data.itemID) && (data[propertyAreaIDFrom][i] == data.itemID) && (condition == undefined || condition[i])) {
			data[propertyInner][timeframe] += Math.abs(values[i]);
		}

		else {
			if (data[propertAreaIDTo][i] == data.itemID && (condition == undefined || condition[i])) {

				if (values[i] > 0) {
					data[propertyFrom][timeframe] += values[i];

				} else {
					data[propertyTo][timeframe] -= values[i];
				}

				if (data[propertyAreaIDFrom][i] == data.itemID && (condition == undefined || condition[i])) {

					if (values[i] > 0) {
						data[propertyTo][timeframe] += values[i];

					} else {
						data[propertyFrom][timeframe] -= values[i];
					}
				}
			}
		}
	}
}

function addValuesForTimeframeAndID(data, timeframe, property, idValues, values) {

	if (idValues[i] == data.itemID) {
		if (data[property][timeframe] == undefined) {
			data[property][timeframe] = 0;
		}
		data[property][timeframe] += values[i];
	}

}



function barPlot(plotElementID, data, timeframe, properties, colors, titles, layout) {

	var traces = [];

	for (let i = 1; i < properties.length; i++) {

		let trace = {
			x: [],
			y: [],
			marker: {
				color: []
			},
			name: [],
			type: 'bar'
		}

		let property = properties[i];

		trace.x.push(titles[property]);
		trace.y.push(data[property][timeframe]);

		trace.marker.color.push("rgba(" + colors[property].join(",") + ")");
		trace.name = titles[property];

		traces.push(trace);
	}



	var layout = {
		showlegend: true,
	};

	copyAndStorePreviousTraceVisibility(plotElementID, traces);

	Plotly.newPlot(plotElementID, traces, layout);
}

function copyAndStorePreviousTraceVisibility(elementName, traceData) {
	let divElement = document.getElementById(elementName);
	if (divElement != null) {

		if (divElement.traceData != null) {

			for (oldTrace of divElement.traceData) {

				for (newTrace of traceData) {
					if (newTrace.name == oldTrace.name) {
						newTrace.visible = oldTrace.visible;
					}
				}
			}
		}

		divElement.traceData = traceData;
	}
}

/**
 * Function assumes 
 */
function xyPlot(plotElementID, type, data, properties, colors, titles, layout) {

	var traces = [];
	let timeframeProperty = properties[0];

	for (let i = 1; i < properties.length; i++) {

		let property = properties[i];
		let trace = {
			x: data[timeframeProperty],
			y: data[property],
			marker: {
				color: "black"
			},
			line: {
				color: "rgba(" + colors[property].join(",") + ")"
			},
			name: titles[property],
			type: type,
			mode: 'lines+markers'
		}

		traces.push(trace);
	}

	if (layout == undefined) {
		layout = createLayout();
		layout.showLegend = true;
	}
	
	copyAndStorePreviousTraceVisibility(plotElementID, traces);

	Plotly.newPlot(plotElementID, traces, layout);
}

function volumeStackedPlot(plotElementID, data, properties, colors, titles, layout, percentual = false) {

	var traces = [];
	for (let i = 1; i < properties.length; i++) {
		series = {};

		series.x = [];
		series.y = [];

		if (titles != null && titles[properties[i]] != null) {
			series.name = titles[properties[i]];
		}
		series.stackgroup = 'one';
		if (percentual) {
			series.groupnorm = 'percent';
		}
		series.fillcolor = "rgba(" + colors[properties[i]].join(",") + ")";

		for (let t = 0; t < data[properties[i]].length; t++) {
			series.x.push(data[properties[0]][t]);
			series.y.push(data[properties[i]][t]);
		}

		traces.push(series);
	}

	if (layout == undefined) {
		layout = {};
	}
	if (layout.title == undefined) {
		layout.title = {
			text: percentual ? 'Percentual Volume Stack' : 'Volume Stack'
		}
	}
	copyAndStorePreviousTraceVisibility(plotElementID, traces);

	Plotly.newPlot(plotElementID, traces, layout)
}





function sankeyPlot(
	plotDivName,
	links,
	timeframe,
	properties,
	titles,
	layout,
	colors = null,
	positionsX = null,
	positionsY = null
) {

	let link = getLink(links, timeframe);
	
	labels = [];
	for (var i = 0; i < properties.length; i++) {
		labels.push(titles[properties[i]]);
	}

	let node = {
		pad: 15,
		thickness: 20,
		line: { color: "black", width: 0.5 },
		label: labels,
		align: "right"
	};

	if (colors !== null) {
		node.color = properties.map(p => colors[p]);
	}

	if (positionsX !== null && positionsY !== null) {
		node.x = properties.map(p => positionsX[p]);
		node.y = properties.map(p => positionsY[p]);
	}

	let data = {
		type: "sankey",
		orientation: "h",
		node: node,
		link: link
	};

	Plotly.newPlot(plotDivName, [data], layout);
}

function createRadarPlot(plotDivName, labels, values, range, layout) {

	if (Array.isArray(values)) {
		console.error('Array provided for Radarplot rather than mapping. Placing values in mapping under key "Values".');
		values = { 'Values': values };
	}

	let plotLabels = labels.slice(0, labels.length);
	plotLabels.push(labels[0]);

	let plotData = [];
	for (let i in values) {

		let plotValues = [];
		for (let l = 0; l < labels.length; l++) {
			plotValues[l] = values[i][l] ?? 0;
		}

		plotValues.push(plotValues[0]);

		plotData.push({
			type: 'scatterpolar',
			r: plotValues,
			theta: plotLabels,
			fill: 'toself',
			name: i,
			showlegend: true,
		});
	}

	let plotLayout = JSON.parse(JSON.stringify(layout)); //deep copy

	plotLayout['polar'] ??= {
		radialaxis: {
			visible: true,
			direction: 'clockwise',
			range: [Math.min.apply(null, range), Math.max.apply(null, range)]
		},
		angularaxis: {
			direction: 'clockwise'
		},
	};

	Plotly.newPlot(plotDivName, plotData, plotLayout);

}

function createPiePlot(plotDivName, labels, values, layout) {
	if (!Array.isArray(values)) {
		throw new Error('PiePlot requires an array of values. Provided was: ' + (typeof values));
	}

	let plotLabels = labels;
	let plotValues = values;

	let plotData = [{
		'labels': plotLabels,
		'values': plotValues,
		'type': 'pie',
		'sort': false
	}];

	let plotLayout = layout;

	Plotly.newPlot(plotDivName, plotData, plotLayout);

}

function createLayout() {
	/**
	 * See https://plotly.com/javascript/reference/layout/
	 */

	const layout = {
		title: {
			automargin: undefined,
			font: undefined, /*{color, family, lineposition,shadow, size style, textcase, variant, weight}*/
			pad: undefined,  /*b, l ,r ,t*/
			subtitle: undefined, /*{
						font: undefined, 
						text: undefined		
						x: undefined,
						xanchor: undefined,
						xref: undefined,
						y: undefined, 
						yanchor: undefined, 
						yref: undefined,}*/

			text: undefined,
			x: undefined,
			xanchor: undefined,
			xref: undefined,
			y: undefined,
			yanchor: undefined,
			yref: undefined,
		},
		showLegend: undefined,

		legend: {
			bgcolor: undefined,
			bordercolor: undefined,
			borderwidth: undefined,
			entrywidth: undefined,
			entrywidthmode: undefined,
			font: undefined,
			groupclick: undefined,
			grouptitlefont: undefined,
			indentation: undefined,
			itemclick: undefined,
			itemdoubleclick: undefined,
			itemsizing: undefined,
		}, //etc

		xaxis: {

			title: {

				text: '',

				font: {

				}

			},

		},

		yaxis: {

			title: {

				text: '',

				font: {

				}

			}

		}
	};
	return layout;
}

function createVolumePlotLayout() {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	return layout;
}

function createBarPlotLayout(title) {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	layout.title.text = title;
	return layout;
}

function createSankeyPlotLayout() {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	return layout;
}

function createRadarPlotLayout() {
	const layout = createLayout();
	layout['legend'] ??= {};
	layout['margin'] ??= {};

	Object.assign(layout['margin'], {
		t: 32,
		b: 32,
		l: 48,
		r: 48,
		pad: 0,
		autoexpand: true,
	});
	layout['showlegend'] ??= true;
	layout['autosize'] ??= true;

	return layout;
}

function createPiePlotLayout() {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	return layout;
}



class QueryDataObject {
	constructor(args) {
		args = Object.assign({
			query: null,
			fallbackData: null,
			x: null,
			y: null,
		}, args);

		this.query = args['query'];
		this.setQueryData(args['query']);
		this.setFallbackData(args['fallbackData']);

		this.setDimensionX(args['x']);
		this.setDimensionY(args['y']);
	}

	query = null;
	queryData = null;
	fallbackData = null;
	x = null;
	y = null;

	getData(allowFallbackData = true) {
		if (this.hasResolvedQueryData()) {
			return this.getQueryData();
		}
		if (!allowFallbackData) {
			throw 'Query not resolved and no fallback data allowed: ' + this.query;
		}

		if (this.hasResolvedFallbackData()) {
			return this.getFallbackData();
		}
		throw 'Query not resolved and no fallback data available: ' + this.query;
	}

	getQueryData() {
		let data = this.queryData;
		data = this.constructor.copyData(data);
		if (this.hasNoDimensions()) {
			return ArrayUtils.unArrayIfSingleElement(data);
		}
		return data;
	}
	getFallbackData() {
		let data = this.fallbackData;
		data = this.constructor.copyData(data);
		if (this.hasNoDimensions()) {
			return ArrayUtils.unArrayIfSingleElement(data);
		}
		return data;
	}

	setQueryData(data) {
		this.queryData = data === null ? null : QueryDataObject.parseToData(data);
	}

	setFallbackData(data) {
		this.fallbackData = data === null ? null : QueryDataObject.parseToData(data);
	}
	setDimensionX(data) {
		this.x = data ?? null;
	}
	setDimensionY(data) {
		this.y = data ?? null;
	}

	getDimensionX() {
		return this.x;
	}
	getDimensionY() {
		return this.y;
	}
	getDimensionCount() {
		return this.getDimensionX() + this.getDimensionY();
	}

	hasDimensionX() {
		return this.x !== null;
	}

	hasDimensionY() {
		return this.y !== null;
	}
	hasDimension(dimension) {
		if (this.hasDimensionX() && this.getDimensionX() == dimension) {
			return true;
		}
		if (this.hasDimensionY() && this.getDimensionY() == dimension) {
			return true;
		}
		return false
	}
	hasNoDimensions() {
		return this.getDimensionCount() == 0;
	}

	hasQueryData() {
		return QueryDataObject.exists(this.queryData);
	}
	hasResolvedQueryData() {
		return QueryDataObject.appearsResolved(this.queryData);
	}
	hasFallbackData() {
		return QueryDataObject.exists(this.fallbackData);
	}
	hasResolvedFallbackData() {
		return QueryDataObject.appearsResolved(this.fallbackData);
	}

	isAllQueryDataResolved() {
		if (this.hasFallbackData() && !this.hasResolvedFallbackData()) {
			return false;
		}
		if (this.hasQueryData() && !this.hasResolvedQueryData()) {
			return false;
		}
		return true;
	}

	static parseToData(value) {
		if (Array.isArray(value)) {
			//Arrays can always be considered already-processed and thus fine as-is.
			return value;
		}
		//Simple quick parse
		let parsedValue = null;
		try {
			parsedValue = JSON.parse('[' + value + ']');
		} catch (err) {
			parsedValue = value;
		}
		return parsedValue;
	}
	static copyData(data) {
		//Copy data on retrieval to prevent unintended modifications to source data
		//Deep-copies required for matrix-type data, but query data is never too complex for simple JSON-method
		return JSON.parse(JSON.stringify(data));
	}

	static exists(value) {
		if (typeof value === 'undefined') {
			return false;
		}
		if (value === null) {
			return false;
		}
		return true;
	}
	static appearsResolved(value) {
		if (!QueryDataObject.exists(value)) {
			return false;
		}
		if (!value.indexOf) {
			//could be a number
			return true;
		}
		//split the query string, otherwise it "resolves" when used in the Tygron Platform
		return !(value.indexOf('$') === 0) && (value.indexOf('SELECT_') !== 1);
	}
}

class QueryDataManager {

	constructor(args = {}) {
		args = Object.assign({
			allowFallbackData: true,
			sizedKeys: {}
		}, args);

		this.setAllowFallbackData(args['allowFallbackData']);
		for (let key in args['sizedKeys']) {
			this.setSizedKey(key, args['sizedKeys'][key]);
		}
	}

	allowFallbackData = true;

	sizedKeys = {};
	queryDataObjects = {};

	addQueryData(key, args = {}) {
		args = Object.assign({
			query: null,
			fallbackData: null,
			x: null,
			y: null,
		}, args);

		let queryData = new QueryDataObject(args);
		this.queryDataObjects[key] = queryData;

		return queryData;
	}

	addQuery(key, query) {
		return this.addQueryData(key, { query: query });
	}

	addQueryDatas(queries = {}) {
		for (let queryKey in queries) {
			this.addQueryData(queryKey, queries[queryKey]);
		}
	}

	hasData(key) {
		return (!!this.queryDataObjects[key]);
	}

	getData(key, forceToArray = true) {
		let queryDataObject = this.getQueryDataObject(key);
		let data = queryDataObject.getData(this.allowFallbackData);
		return forceToArray ? ArrayUtils.coerceToArray(data) : data;
	}

	getDataMatrix(key, outerArrayKey = null, innerArrayKey = null) {
		let data = this._getDataMatrixUnbounded(key, outerArrayKey, innerArrayKey);

		let innerSize = this.sizedKeys[innerArrayKey];
		let outerSize = this.sizedKeys[outerArrayKey];

		if (((innerSize ?? null) != null) || ((outerSize ?? null) != null)) {
			data = ArrayUtils.clampMatrixSize(data, 0, outerSize, outerSize, innerSize, innerSize);
		}

		return data;
	}

	getDataKeyValues(key, kvIndex) {
		let queryDataObject = this.getQueryDataObject(key);

		if (queryDataObject.hasNoDimensions()) {
			throw new RangeError('Cannot request key-value mapping from dimensionless data registered by key ' + key);
		}

		let data = this.getDataMatrix(key, null, kvIndex);
		data = ArrayUtils.mapFromKeyValueMatrix(data);
		if (queryDataObject.getDimensionCount() == 1) {
			return ArrayUtils.unArrayIfSingleElement(data);
		}
		return data;
	}

	getDataKeyIndexed(key, kvIndex, indexKeys) {
		let data = this.getDataMatrix(key, kvIndex);

		if (ArrayUtils.isMatrix(indexKeys)) {
			throw new TypeError('Cannot index data by matrix');
		}

		if (Array.isArray(indexKeys) && !Array.isArray(data)) {
			throw new TypeError('Cannot index singular data by array');
		}
		if (!Array.isArray(indexKeys)) {
			if (this.hasData(indexKeys)) {
				return this.getDataKeyIndexed(key, kvIndex, this.getData(indexKeys));

			}
			let result = {};
			result[indexKeys] = data;
			return result;
		}

		let map = {};
		for (let i = 0; i < Math.min(data.length, indexKeys.length); i++) {
			map[indexKeys[i]] = data[i];
		}
		return map;
	}

	_getDataMatrixUnbounded(key, outerArrayKey = null, innerArrayKey = null) {
		//x in query is inner , y in query is outer
		let queryDataObject = this.getQueryDataObject(key);

		//Dimensionless		
		if (!outerArrayKey && !innerArrayKey) {
			if (queryDataObject.hasNoDimensions()) {
				return queryDataObject.getData(this.allowFallbackData);
			}
			if (queryDataObject.getDimensionCount() > 1) {
				throw new RangeError('No dimension(s) defined while requesting data by key ' + key);
			}
			//Undefined dimensions
		} else if (outerArrayKey == innerArrayKey) {
			throw new RangeError('Cannot request duplicate dimension ' + outerArrayKey + ' for data registered by key ' + key)
		}

		if (outerArrayKey && (!queryDataObject.hasDimension(outerArrayKey))) {
			throw new RangeError('Dimension ' + outerArrayKey + ' not known for data registered by key ' + key);
		}
		if (innerArrayKey && (!queryDataObject.hasDimension(innerArrayKey))) {
			throw new RangeError('Dimension ' + innerArrayKey + ' not known for data registered by key ' + key);
		}

		// 2 Dimensions
		if (queryDataObject.hasDimensionX() && queryDataObject.hasDimensionY()) {
			if (innerArrayKey == queryDataObject.getDimensionX() || outerArrayKey == queryDataObject.getDimensionY()) {
				return queryDataObject.getData(this.allowFallbackData);
			} else {
				return ArrayUtils.flipMatrix(queryDataObject.getData(this.allowFallbackData));
			}
		}

		// X dimension
		else if (queryDataObject.hasDimensionX()) {
			if (innerArrayKey == queryDataObject.getDimensionX()) {
				return [queryDataObject.getData(this.allowFallbackData)];
			} else if (outerArrayKey === null || outerArrayKey == queryDataObject.getDimensionX()) {
				return queryDataObject.getData(this.allowFallbackData);
			}

		}

		//Y dimension
		else if (queryDataObject.hasDimensionY()) {
			if (innerArrayKey == queryDataObject.getDimensionY()) {
				return ArrayUtils.flipMatrix(queryDataObject.getData(this.allowFallbackData));
			} else if (outerArrayKey === null || outerArrayKey == queryDataObject.getDimensionY()) {
				let data = ArrayUtils.coerceToArray(queryDataObject.getData(this.allowFallbackData))
				return [].concat(...data);
			}

		}

		//Undefined
		throw new RangeError('Unknown state occured while requesting data of key ' + key + ' with dimension(s) ' + outerArrayKey + ', ' + innerArrayKey);
	}

	getQueryDataObject(key) {
		let queryDataObject = this.queryDataObjects[key];
		if (!queryDataObject) {
			throw new RangeError('No QueryData registered with key ' + key);
		}
		return queryDataObject;
	}

	getUnresolvedDataKeys() {
		let unresolved = [];
		for (let key of Object.keys(this.queryDataObjects)) {
			if (!this.getQueryDataObject(key).isAllQueryDataResolved()) {
				unresolved.push(key);
			}

		}
		return unresolved;
	}

	setAllowFallbackData(allow) {
		this.allowFallbackData = (!!allow);
	}

	setSizedKey(key, size) {
		if (size === null) {
			delete this.sizedKeys[key];
		} else {
			this.sizedKeys[key] = size;
		}
	}

	allQueriesResolved() {
		return this.getUnresolvedDataKeys().length === 0;
	}

}
function connector(token, baseUrl, basePath,) {
	
	return {
		token : token ?? null,
		basePath : basePath ?? '/api/session/',
		baseUrl : baseUrl ?? null,
		protocol: 'https',
		
		start(funcToRun) {
			return (typeof funcToRun === 'function') ? Promise.resolve(funcToRun()) : Promise.resolve(funcToRun ?? null);
		},
		
		get(url, queryParams, preparationFunction) {
			let self = this;
			return function(data) {
				return self._call( 'GET', url, queryParams, null, preparationFunction )();
			}
		},
		post(url, queryParams, params, preparationFunction) {
			let self = this;
			return function(data) {
				return self._call( 'POST', url, queryParams, params, preparationFunction )();
			}
		},
		
		recalculate( xqueries ) {
			let self = this;
			return function(data) {
				return self.post('/api/session/event/editorindicator/reset_indicators/',null,[!!xqueries])(data);
			}
		},

		consoleLog: function(message) {
			return function(data) {
				if (message) {
					console.log(message);
				}
				console.log(data);
				return data;
			}
		},
		
		_prepareQueryString: function(queryParams, url) {
			queryParams = queryParams ?? {};
			let queryString = new URLSearchParams(queryParams).toString();
			if ( queryString.length > 0 ) {
				if ( url.indexOf('?')===-1 ) {
					queryString = '?'+ queryString;
				} else {
					queryString = '&'+ queryString;
				}
			}
			return queryString;
		},
		
		_prepareQueryParams: function(queryParams) {
			queryParams = queryParams ?? {};
			if ( !(typeof queryParams === 'object') ) {
				queryParams = {};
			}
			return queryParams;
		},
		
		_prepareParams: function(params) {
			params = params ?? [];
			if (!Array.isArray(params)) {
				params = [params];
			}
			return params;
		},
		
		_call: function (method, url, queryParams, params, preparationFunction) {
			let self = this;
			return function(data) {
				params = method.toUpperCase() == 'GET' ? null : self._prepareParams(params);
				queryParams = self._prepareQueryParams(queryParams);
				queryParams['token'] = queryParams['token'] ?? self.token;
				queryParams['f'] = queryParams['f'] ?? 'JSON';
				
				if (typeof preparationFunction == 'function') {
					url = preparationFunction(data, url, queryParams, params) ?? url;
				}
				
				let queryString = self._prepareQueryString(queryParams, url);
				if ( self.basePath && !(url.indexOf('/')==0) ) {
					url = self.basePath + url;
				}
				if (self.baseUrl) {
					url = self.protocol + self.baseUrl + url;
				}
				url = url + queryString;
				
				let promise = Promise.resolve(
					$.ajax({
						url: url,
						method: method.toUpperCase(),
						contentType: 'application/json',
						dataType: 'json',
						data: JSON.stringify(params),
					})
				);
				return promise;
			};
		},

		//To use a single argument which is an array itself, wrap the arguments in an array.
		chain: function(func, args) {
			if ( typeof args === 'undefined' ) {
				return function(data) {
					return func(data);
				}
			}
			if ( Array.isArray(args) ) {
				return function(data) {
					return func.apply(this, args.slice().unshift(data));
				}
			}
			return function(data) {
				return func.apply(this, [data, args]);
			}
		},
	};
}

function addDownloadHandler(element, fileName, contentFunction) {

	element.addEventListener('click', () => {

		let content = contentFunction();
		let blob = new Blob([content], { type: 'text/plain' });

		// temp link 
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		link.download = fileName;
		link.click();

		// cleanup
		URL.revokeObjectURL(link.href);
	});
}

function toCSVContent(data, properties, titles, timeframes) {
	if (Array.isArray(data)) {
		return _toCSVContentArray(data, properties, titles, timeframes);
	} else {
		return _toCSVContentObject(data, properties, titles, timeframes);
	}
}

function _toCSVContentObject(data, properties, titles, timeframes) {

	let csvContent = "";

	for (let i = 0; i < properties.length; i++) {
		csvContent += titles[properties[i]];
		csvContent += i < properties.length - 1 ? "," : "\r\n";
	}

	for (let t = 0; t < timeframes; t++) {
		for (let i = 0; i < properties.length; i++) {
			csvContent += data[properties[i]][t];
			csvContent += i < properties.length - 1 ? "," : "\r\n";
		}
	}
	return csvContent;
}

function _toCSVContentArray(data, properties, titles, timeframes) {

	let csvContent = "";

	for (let e = 0; e < data.length; e++) {
		let entry = data[e];
		for (let i = 0; i < properties.length; i++) {
			csvContent += entry[properties[0]] + " " + titles[properties[i]];
			csvContent += e == data.length - 1 && i == properties.length - 1 ? "\r\n" : ",";
		}
	}

	for (let t = 0; t < timeframes; t++) {
		for (let e = 0; e < data.length; e++) {
			let entry = data[e];
			for (let i = 0; i < properties.length; i++) {

				csvContent += t < entry[properties[i]].length ?
					entry[properties[i]][t] :
					entry[properties[i]][entry[properties[i]].length - 1];

				csvContent += e == data.length - 1 && i == properties.length - 1 ? "\r\n" : ",";
			}
		}
	}
	return csvContent;
}

function hasRequiredAttributesAndValues(item, requiredAttributes) {

	for (const key of requiredAttributes.keys()) {

		if (item.attributes == null) {
			return false;
		}

		let value = requiredAttributes[key];

		if (value == null && !(key in item.attributes)) {

			return false;

		} else if (value != null && item.attributes[key] != value) {

			return false;
		}
	}
	return true;
}

function hasRequiredAttribute(item, requiredAttribute) {
	return item.attributes != null && item.attributes[requiredAttribute] != null;
}

function hasRequiredAttributes(item, requiredAttributes) {

	if (requiredAttributes instanceof Map) {
		return hasRequiredAttributesAndValues(item, requiredAttributes);

	} else if (Array.isArray(requiredAttributes)) {
		
		for (let i = 0; i < requiredAttributes.length; i++) {
			if (!hasRequiredAttribute(item, requiredAttributes[i])) {
				return false;
			}
		}
		return true;

	} else if (typeof requiredAttributes == "string") {
		return hasRequiredAttribute(item,requiredAttributes);

	} else if (requiredAttributes != null) {

		throw new Exception("Unhandled requiredAttribute type: " + requiredAttributes);
	}

	return true;



}


function isGridOverlay(overlay) {
	if (overlay == null || overlay.type == null) {
		return false;
	}

	return isGridType(overlay.type);

}

function isGridType(type) {
	if (type == null || typeof type !== 'string') {
		return false;
	}

	switch (type) {
		case "AVG":
		case "COMBO":
		case "DISTANCE":
		case "DISTURBANCE_DISTANCE":
		case "FLOODING":
		case "GEO_TIFF":
		case "GROUNDWATER":
		case "HEAT_STRESS":
		case "HEIGHTMAP":
		case "INFERENCE":
		case "ITERATION":
		case "LIVABILITY":
		case "NETWORK_DISTANCE":
		case "OWNERSHIP_GRID":
		case "RAINFALL":
		case "RESULT_CHILD":
		case "SAFETY_DISTANCE":
		case "SATELLITE":
		case "SHADOW":
		case "SIGHT_DISTANCE":
		case "SUBSIDENCE":
		case "TEST":
		case "TRAFFIC_NO2":
		case "TRAFFIC_NOISE":
		case "TRAVEL_DISTANCE":
		case "WATERSHED":
		case "WCS":
		case "WMS":
			return true;
		default:
			return false
	}
}

function getResultType(gridOverlay, type) {
	if (gridOverlay == null || gridOverlay.type == null) {
		return null;
	}


	if (gridOverlay.resultType != null) {
		return gridOverlay.resultType;
	}

	switch (type) {
		case "AVG":
		case "LIVABILITY":
		case "OWNERSHIP_GRID":
			return "AVG";
		case "COMBO":
		case "ITERATION":
		case "NETWORK_DISTANCE":
		case "SATELLITE":
		case "TEST":
			return "DEFAULT";
		case "DISTANCE":
		case "DISTURBANCE_DISTANCE":
		case "SAFETY_DISTANCE":
			return "ZONE"
		case "FLOODING":
		case "RAINFALL":
		case "GROUNDWATER":
			return "SURFACE_LAST_VALUE";
		case "GEO_TIFF":
			return "NEAREST";
		case "HEAT_STRESS":
			return "PET";
		case "HEIGHTMAP":
			return "DSM";
		case "INFERENCE":
			return "LABELS";
		case "RESULT_CHILD":
			return "";
		case "SHADOW":
			return "SHADE";
		case "SIGHT_DISTANCE":
			return "SIGHT";
		case "SUBSIDENCE":
			return "SUBSIDENCE";
		case "TRAFFIC_NO2":
			return "CONCENTRATION";
		case "TRAFFIC_NOISE":
			return "NOISE_DB";
		case "TRAVEL_DISTANCE":
			return "DESTINATIONS";
		case "WATERSHED":
			return "WATERSHEDS";
		case "WCS":
			return "NEAREST";
		case "WMS":
			return "COLOR";
		default:
			return "";
	}
}

function getResultParentID(gridOverlay) {
	if (gridOverlay == null || gridOverlay.parentID == null) {
		return null;
	}
	return gridOverlay.parentID;
}

function getOverlay(overlays, id) {
	for (let i = 0; i < overlays.length; i++) {
		if (overlays[i] != null && overlays[i].id == id) {
			return overlays[i];
		}
	}
	return null;
}


function isOverlayOf(overlay, type, resultType, resultParentID, requiredAttributes) {
	if (overlay == null) {
		return false;
	}

	if (type != null && type != overlay.type) {
		return false;
	}

	if (resultType != null && resultType != getResultType(overlay)) {
		return false;
	}

	if (resultParentID != null && (resultParentID != getResultParentID(overlay) && overlay.id != resultParentID)) {
		return false;
	}

	if (!hasRequiredAttributes(overlay, requiredAttributes)) {
		return false;
	}


	return true;
}

function getGridOverlay(overlays, type, resultType, resultParentID, requiredAttributes) {

	for (let i = 0; i < overlays.length; i++) {
		let overlay = overlays[i];

		if (isOverlayOf(overlay, type, resultType, resultParentID, requiredAttributes)) {
			return overlay;
		}
	}

	return null;


}

function getGridOverlays(overlays, type, resultType, resultParentID, requiredAttributes) {

	let gridOverlays = [];

	if (!Array.isArray(overlays)) {
		return gridOverlays;
	}

	for (let i = 0; i < overlays.length; i++) {
		let overlay = overlays[i];
		if (isGridOverlay(overlay) && isOverlayOf(overlay, type, resultType, resultParentID, requiredAttributes)) {
			gridOverlays.push(overlay);
		}
	}

	return gridOverlays;
}



function isTemplateTextPanel(panel, templateMapLink, templateAttribute, requiredAttributes) {
	// Is non template?	
	if (panel == null || panel.autoApplied == null) {
		return false;
	}

	// Check template panel type
	if (panel.excelID != null) {
		return false;
	}

	if (templateMapLink != null && panel.mapLink != templateMapLink) {
		return false;
	}

	if (templateAttribute != null && panel.attribute != templateAttribute) {
		return false;
	}

	if (hasRequiredAttributes != null && !hasRequiredAttributes(panel, requiredAttributes)) {
		return false;
	}

	return true;

}

function getTemplateTextPanel(panels, templateMapLink, templateAttribute, requiredAttributes) {

	if (!Array.isArray(panels)) {
		return panels;
	}

	for (let i = 0; i < panels.length; i++) {

		if (isTemplateTextPanel(panels[i], templateMapLink, templateAttribute, requiredAttributes)) {
			return panels[i];
		}
	}

	return null;


}

function getTemplateTextPanels(panels, templateMapLink, templateAttribute, requiredAttributes) {

	let templateTextPanels = [];

	if (!Array.isArray(panels)) {
		return templateTextPanels;
	}

	for (let i = 0; i < panels.length; i++) {

		if (isTemplateTextPanel(panels[i], templateMapLink, templateAttribute, requiredAttributes)) {
			templateTextPanels.push(panels[i]);
		}
	}

	return templateTextPanels;
}

function initCollapsibles() {

	let collapsible = document.getElementsByClassName("collapsible");
	
	for (let i = 0; i < collapsible.length; i++) {
		
		collapsible[i].addEventListener("click", function() {

			this.classList.toggle("active");
			let content = this.nextElementSibling;
			let style = content.style;

			if (content.classList.contains("delayed")) {
				
				if (style.maxHeight) {
					style.maxHeight = null;
				} else {
					style.maxHeight = content.scrollHeight + "px";
				}
			
			} else {
				style.display = style.display === "block" ? "none" : "block";
			}


		});
	}
}

function openCollapsibles() {
	
	let  collapsible = document.getElementsByClassName("collapsible");
	for (i = 0; i < collapsible.length; i++) {
		
		const collapsible = collapsible[i];
		setTimeout(function() {
			collapsible.click();
		}, i * 100);
	}
}
function ensureDomElement(domElementId) {

	let domElement = domElementId;
	if (!(domElement instanceof HTMLElement)) {
		domElement = document.getElementById(domElementId);
	}

	if (!(domElement instanceof HTMLElement)) {
		throw 'No element found matching ' + domElementId;
	}

	return domElement;
}

function attachHandler(parentElement, eventType, selector, handler, referenceClass) {

	let checkHandler = function(event) {
		event = event || window.event;
		event.target = event.target || event.srcElement;

		let foundElement = selector ? event.target.closest(selector) : parentElement;
		if (foundElement) {
			handler.call(foundElement, event);
		}
	};

	if (parentElement.addEventListener) {
		parentElement.addEventListener(eventType, checkHandler, false);
	}

	if (referenceClass) {
		parentElement.classList.add(referenceClass);
	}
}

function popupPanel(parent, panelID, webPath) {

	let popupPanel = document.createElement('div');
	popupPanel.classList.add('popup');

	let panelCloser = document.createElement('div');
	panelCloser.classList.add('closer');
	attachHandler(panelCloser, 'click', null, function() { clearPopupPanel(parent); });

	let panelFrame = document.createElement('iframe');
	panelFrame.classList.add('popupFrame');

	popupPanel.appendChild(panelCloser);
	popupPanel.appendChild(panelFrame);

	webPath = webPath ?? '/web/panel.html';
	let queryString = 'token=$TOKEN&id=' + panelID;
	let webTarget = webPath + (webPath.indexOf('?') < 0 ? '?' : '&') + queryString;
	panelFrame.src = webTarget;

	clearPopupPanel(parent);
	parent.appendChild(popupPanel);
}

function clearPopupPanel(element) {
	let popups = element.getElementsByClassName('popup');
	for (let i = 0; i < popups.length; i++) {
		popups[i].remove();
	}
	return element;
}

function removeAllChildren(element) {
	while (element.children.length > 0) {
		element.removeChild(element.children[element.children.length - 1]);
	}
}



/**
 * Listing Panel
 * 
 * To display a matrix of information with flexible rendering rules.
 * headers/content/footers : 
 * 		A matrix of values ( 0...n rows/arrays with 0...n values ) to display
 * headersTypes/contentTypes/footerTypes : 
 * 		A matching matrix of rendering types. Either predefined of functions. Either one array for all rows, or a matrix. Missing rows in a matrix use defaultTypes instead
 * defaultHeadersTypes/defaultContentTypes/defaultFootersTypes : 
 * 		A single renderer definition (or array of multiple matching one row) to render with if no list of renderers is provided
 * tableMode : 
 * 		Whether to render as an HTML table. If not, will use divs instead, per cell, per row, and one for the full container 
 * flipXY : 
 * 		If true, the rows in the data will be layed out as columns, and vice versa.
 */

class ListingPanelController {
	
	constructor(domTarget, args = {}) {
		this.args = Object.assign( {
				'content' : [],
				'contentTypes' : [],
				'defaultContentTypes' : 'label',
				
				'headers': [],
				'headersTypes' : [],
				'defaultHeaderTypes' : 'label',
				
				'footers':[],
				'footersTypes': [],
				'defaultFootersTypes': 'label',
				
				'tableMode': true,
				'flipXY' : false,
			}, args );
		
		this.parent = null;
		this.domElement = null;
		
		try {
			this.parent = ensureDomElement(domTarget);
		} catch( err ) {
		}
	}

	addContent(content, renderTypes = null) {
		this.args['content'].push(content);
		if (renderTypes) {
			let index = this.args['content'].length -1;
			this.args['contentTypes'][index] = renderTypes;
		}
	}
	addHeader(content, renderTypes = null) {
		this.args['headers'].push(content);
		if (renderTypes) {
			let index = this.args['content'].length -1;
			this.args['footersTypes'][index] = renderTypes;
		}
	}
	addFooter(content, renderTypes = null) {
		this.args['footers'].push(content);
		if (renderTypes) {
			let index = this.args['content'].length -1;
			this.args['headersTypes'][index] = renderTypes;
		}
	}

	clearContent() {
		this.args['content'] = [];
		this.args['contentTypes'] = [];
	}
	clearHeader() {
		this.args['headers'] = [];
		this.args['footersTypes'] = [];
	}
	clearFooter() {
		this.args['footers'] = [];
		this.args['headersTypes'] = [];
	}
	
	setDefaultContentRenderTypes(renderTypes) {
			this.args['defaultContentTypes'] = renderTypes;
	}
	setDefaultHeaderRenderTypes(renderTypes) {
			this.args['defaultHeadersTypes'] = renderTypes;
	}
	setDefaultFootersRenderTypes(renderTypes) {
			this.args['defaultFootersTypes'] = renderTypes;
	}
	
	/* Based on the configuration and content, create the actual dom elements. */
	render( rerender = true ) {
		if (this.domElement && ! rerender) {
			return this.domElement;
		}
		
		let renderRules = this._createRenderRules(this.args)
		if (this.args['flipXY']) {
			renderRules = ArrayUtils.flipMatrix(renderRules);
		}
		let domElement = this._createDomElement(renderRules, this.args['tableMode']);
		
		if (this.parent) {
			if (this.domElement) {
				this.parent.removeChild(this.domElement);
			}
			this.parent.appendChild(domElement);
		}
		
		this.domElement = domElement;
	}
	
	getValues(section='content') {
		let selector = 'entry'+  (section ? ' '+section : '');
		let entries = this.domElement.getElementsByClassName(selector);
		
		let values = [];
		for (let entry of entries) {
			let entryValues = [];
			let inputs = entry.getElementsByClassName('input');
			for (let input of inputs) {
				entryValues.push(this._getValueFromInput(input));
			}
			values.push(entryValues);
		}
		return values;
	}
	
	getRenderer(type, args) {
		type = type ?? 'label';
		if (typeof type === 'function') {
			return type;
		}
		
		let renderer = null;
		try {
			renderer = ListingPanelController.getRenderer(type, args);
		} catch (err) {
			console.error('Failed to get renderer type '+type+', reason: '+err);
			renderer = ListingPanelController.getRenderer('label');
		}
		return renderer;
	}
	
	
	static DEFAULT_CLASS = 'listingPanel';
	
	
	/* Turn the content and provided render types into prepared render rules for each individual cell of the listing */
	_createRenderRules( args = {} ) {
		
		let renderRules = [];
		for ( let i=0 ; i<args['headers'].length ; i++ ) {
			let types = this._getRenderTypesFromMatrix( args['headersTypes'], i, args['defaultHeaderTypes']);
			let prepared = this._createCellRenderRules(args['headers'][i], types, {'special':'header'});
			if (prepared) {
				renderRules.push(prepared);
			}
		}
		for ( let i=0 ; i<args['content'].length ; i++ ) {
			let types = this._getRenderTypesFromMatrix( args['contentTypes'], i, args['defaultContentTypes']);
			let prepared = this._createCellRenderRules(args['content'][i], types, {'special':'content'});
			if (prepared) {
				renderRules.push(prepared);
			}
		}
		for ( let i=0 ; i<args['footers'].length ; i++ ) {
			let types = this._getRenderTypesFromMatrix( args['footersTypes'], i, args['defaultFootersTypes']);
			let prepared = this._createCellRenderRules(args['footers'][i], types, {'special':'footer'});
			if (prepared) {
				renderRules.push(prepared);
			}
		}
		return renderRules;
	}
	
	/* From a matrix of renderttpes, get the appropriate row if possible. Otherwise, use the default Types. */
	_getRenderTypesFromMatrix(matrix, index, defaultTypes = []) {
		if ( Array.isArray(matrix) ) {
			if ( matrix.length == 0 ) {
				return defaultTypes;
			}
			if ( !ArrayUtils.isMatrix(matrix) ) {
				return matrix;
			}
			return matrix[index] ?? defaultTypes;
		}
		return matrix ?? defaultTypes;
	}
	
	/* Create the render rule for an array of individual cells. */
	_createCellRenderRules(contents = null, renderers = [], defaultRules = {}) {
		defaultRules = Object.assign( {
				'content' 	: null, // Default data, overwritten by the actual data
				'rendering' : null, // Default type to use if "types" does not extend as far as datas
				'special' 	: null, // Whether the rules are for headers, footers, or other special contents
			}, defaultRules );
		if ( contents===null ) {
			return [];
		}
		if ( !Array.isArray(contents) ) {
			contents = [contents];
		}
		if ( !Array.isArray(renderers) ) {
			renderers = Array(contents.length).fill(renderers);
		}
		let cellRenderRules = [];
		for (let i=0;i<contents.length;i++) {
			let renderType = renderers[i];
			let renderOptions = null;
			if (renderType && renderType['type']) {
				renderOptions = renderType ?? null;
				renderType = renderType['type'];
			}
			cellRenderRules.push( Object.assign( {}, defaultRules, {
				'content'	: contents[i],
				'rendering'	: renderType ?? defaultRules['rendering'],
				'options'	: renderOptions,
			} ) );
		}
		return cellRenderRules;
	}
	
	_createDomElement(renderRules, tableMode) {
		
		let domElement;
		let domInnerElement;
		
		if (tableMode) {
			domElement = document.createElement('table');
			domInnerElement = document.createElement('tbody');
			domElement.appendChild(domInnerElement);
		} else {
			domElement = document.createElement('div');
			domInnerElement = domElement;
		}
		
		for ( let i = 0 ; i < renderRules.length ; i++ ) {
			let rowElement = this._createDomElementsRow(renderRules[i], tableMode);
			domInnerElement.appendChild(rowElement);
		}
		domElement.classList.add(ListingPanelController.DEFAULT_CLASS);
		
		return domElement;	
	}
	
	/* Generate */
	_createDomElementsRow(rowRenderRules, tablemode) {
		
		let rowElementType = tablemode ? 'tr' : 'div';
		let rowElement = document.createElement(rowElementType);
		rowElement.classList.add('entry');
		
		let specialRow = null;
		
		for ( let i = 0 ; i < rowRenderRules.length ; i++ ) {
			let cellRule = rowRenderRules[i];
			let contentRenderer = this.getRenderer(cellRule['rendering'], cellRule['options']);
			
			let cellElement = contentRenderer(cellRule['content']);
			if (cellRule['special']) {
				cellElement.classList.add(cellRule['special']);
			}
			
			if (tablemode) {
				let wrappingCell = null;
				if (cellRule['special'] === 'header') {
					wrappingCell = document.createElement('th');
				} else {
					wrappingCell = document.createElement('td');
				}
				wrappingCell.appendChild(cellElement);
				cellElement = wrappingCell;
			}
			
			rowElement.appendChild(cellElement);
			
			specialRow = specialRow ?? cellRule['special'];
			if (specialRow !== cellRule['special']) {
				specialRow = false;	
			}
		}
		
		if (specialRow) {
			rowElement.classList.add(specialRow);
		}
		
		return rowElement;
	}
	
	_getValueFromInput(input) {
		if (typeof input.getValue === 'function') {
			return input.getValue();
		}
		let selecteds = input.getElementsByClassName('selected');
		if (selecteds.length>0) {
			return selecteds[0].value;
		}
	}
	
	//Cache to prevent recreating renderers when many values are displayed the same
	static cachedRenderers = {};
	static getRenderer(type, args) {
		if ( typeof type === 'function') {
			return type;
		}
		
		let cacheKey = JSON.stringify([type,args]);
		let renderer = this.cachedRenderers[cacheKey] ?? null;
		if ( renderer ) {
			return renderer;
		}
	
		switch(type) {
			case 'label':
				renderer = this._getRendererLabel(args);
				break;
			case 'buttons':
				renderer = this._getRendererButtons(args);
				break;
			default:
				throw 'Could not find renderer type '+type;
		}
		
		if (renderer === false) {
			throw 'Rendering type '+type+' requires arguments. Use getRenderer(type, args) to prepare this renderer instance.';
		}
		
		this.cachedRenderers[cacheKey] = renderer;
		return renderer;
	}

	static _applyGenericRendererOptions(element, options) {
		
		for (let key in options) {
			let value = options[key];
			if (key === 'style') {
				for (let subKey in value ) element.style[subKey] = value[subKey];
			}
			if (key === 'class') {
				for (let subKey in value ) element.classList.add( value[subKey] );
			}
		}
		return element;
	}
	
	static _getRendererLabel(options) {
		let opt = options;
		return function(content) {
			let element = document.createElement('div');
			element.classList.add('label');
			let labelElement = document.createElement('span');
			labelElement.innerHTML = content;
			element.appendChild(labelElement);
			
			ListingPanelController._applyGenericRendererOptions(element, opt);
			
			return element;
		}
	}
	
	static _getRendererButtons(options) {
		let opt = options;
		if ( !opt || !opt['inputs'] ) {
		throw 'Options required for buttons renderer';
		}
		
		if ( !Array.isArray(opt['inputs'])) {
			throw 'Option "inputs" required for buttons renderer';
		}
		let inputs = opt['inputs'];
		return function(content) {
			let element = document.createElement('div');
			element.classList.add('input');
			element.classList.add('buttons')
			
			for (let i = 0; i < inputs.length ; i++) {
				let inputElement = document.createElement('input');
				inputElement.type = 'button';
				inputElement.value = inputs[i];
				if (inputElement.value == content) {
					inputElement.classList.add('selected');
				}
				element.appendChild(inputElement);
			}
			attachHandler(element, 'click', 'input[type="button"]', function(event){
				let oldElement = this.closest('.buttons').getElementsByClassName('selected');
				if (oldElement.length>0) {
					for( let el of oldElement) {
						el.classList.remove('selected');
					}
					oldElement = oldElement[0] ?? null;
				}
				this.classList.add('selected');
				if (this != oldElement) {
					this.closest('.'+ListingPanelController.DEFAULT_CLASS).dispatchEvent(new Event('change'));
				}
			});
			
			ListingPanelController._applyGenericRendererOptions(element, opt);
			
			return element;
		}
	}
}

function getRGBAInterpolated(value, min, max, maxColor, baseColor) {

	if (baseColor == undefined) {
		baseColor = [255, 255, 255, 0.0]
	}

	let fraction = (value - min) / (max - min);
	let red = Math.round(maxColor[0] * fraction + (1 - fraction) * baseColor[0]);
	let green = Math.round(maxColor[1] * fraction + (1 - fraction) * baseColor[1]);
	let blue = Math.round(maxColor[2] * fraction + (1 - fraction) * baseColor[2]);
	let alpha = maxColor[3] * fraction;

	return "rgba(" + [red, green, blue, alpha].join(",") + ")";
}

function addHeaderRow(table, properties, titles) {
	var header = table.createTHead();
	let headerRow = header.insertRow(-1);

	for (let i = 0; i < properties.length; i++) {

		let cell = headerRow.insertCell(-1);
		cell.innerHTML = titles[properties[i]];
	}
}

function addTimeframeRow(tableBody, timeframe, data, properties, colors) {

	let row = tableBody.insertRow(-1);

	for (let n = 0; n < properties.length; n++) {

		let cell = row.insertCell(-1);

		let labelDiv = document.createElement('div');
		let label = document.createElement('label');

		let propData = data[properties[n]];

		let value = Array.isArray(propData) ?
			timeframe < propData.length ?
				propData[timeframe] :
				propData[propData.length - 1]
			: propData == null ? null : propData;

		if (typeof value == "string") {
			label.innerHTML = value;
		} else if (value instanceof Number || typeof value == "number") {

			let min = 0;
			let max = 0;
			let color = colors[properties[n]];

			if (Array.isArray(propData)) {
				min = Math.min.apply(Math, data[properties[n]]);
				max = Math.max.apply(Math, data[properties[n]]);
				
			}

			if (n === 0) {
				label.innerHTML = value.toFixed();
			} else {
				label.innerHTML = value.toFixed(2);
			}


			if (min === max || color === undefined) {
				labelDiv.style.backgroundColor = 'transparent';
			} else {
				labelDiv.style.backgroundColor = getRGBAInterpolated(value, min, max, color);
			}
		} else {
			label.innerHTML = "-";
		}

		labelDiv.appendChild(label);
		cell.appendChild(labelDiv);

	}
}

function clearTable(table) {
	while (table.children.length > 0) {
		table.removeChild(table.children[table.children.length - 1]);
	}
}

function createTable(divName, data, properties, colors, titles) {

	let table = document.getElementById(divName);
	if (table == undefined) {
		console.log("Element with id: " + divName + " does not exist.");
		return;
	}

	addHeaderRow(table, properties, titles);

	let tableBody = table.createTBody();

	for (let t = 0; t < timeframes; t++) {

		addTimeframeRow(tableBody, t, data, properties, colors);
	}
}
/**
 * @param {Element} parent 
 */
function addTimeframeSlider(parent) {
	let sliderDiv = document.createElement("div");
	sliderDiv.className = "timeframe-slider range--ticks slider-background";

	let style = sliderDiv.style;
	style.setProperty('--max', 1);
	style.setProperty('--min', 0);
	style.setProperty('--step', 1);
	style.setProperty('--tickEvery', 1);
	style.setProperty('--value', 1);
	style.setProperty('--text-value', "1");

	style.setProperty('--primaryColor', "red");
	style.setProperty('--fill-color', "unset");
	style.setProperty('--value-background', "unset");
	style.setProperty('--value-active-color', "unset");

	let sliderInput = document.createElement("input");

	sliderInput.className = "timeframe-slider";
	sliderInput.type = "range";
	sliderInput.min = "0";
	sliderInput.max = "1";
	sliderInput.step = "1";
	sliderInput.value = "1";
	sliderInput.oninput = "this.parentNode.style.setProperty('--value',this.value); this.parentNode.style.setProperty('--text-value', JSON.stringify(this.value))";

	let sliderOutput = document.createElement("output");
	sliderDiv.appendChild(sliderInput);
	sliderDiv.appendChild(sliderOutput);

	if (parent != null) {
		parent.appendChild(sliderDiv);
	}

	sliderDiv.getValue = () => {return sliderDiv.style.getPropertyValue("--value")};

	return sliderDiv;
}

function setupTimeframeSlider(timeframeSlider, timeframe, timeframes, onInput) {

	let sliderInput = timeframeSlider.getElementsByTagName('input')[0];
	if (sliderInput != null) {
		sliderInput.max = timeframes - 1;
		sliderInput.value = timeframe;

		sliderInput.oninput = function() {
			timeframeSlider.style.setProperty('--value', sliderInput.value);
			timeframeSlider.style.setProperty('--text-value', JSON.stringify(sliderInput.value))
			onInput();
		};
	}

	timeframeSlider.style.setProperty('--max', sliderInput.max);
	timeframeSlider.style.setProperty('--min', 0);
	timeframeSlider.style.setProperty('--step', 1);
	timeframeSlider.style.setProperty('--tickEvery', 1);
	timeframeSlider.style.setProperty('--value', sliderInput.value);
	timeframeSlider.style.setProperty('--text-value', JSON.stringify(sliderInput.value));

}




class ArrayUtils {

	/** 
	 * 	Rescale a value to desired range. 
	 * 		E.g. Turn fraction into neat percentage: scaleValue(fraction, [0,1], [0,100], true)
	 * 		Non-numeric value input is ignored and returned as-is.
	 * 		originalRange and targetRange must be an array of exactly 2 different numbers
	*/
	static scaleValue(value, originalRange, targetRange, round = false) {
		if (!NumberUtils.isNumeric(value)) {
			return value;
		}
		if ((!this.isRange(originalRange)) || (!this.isRange(targetRange))) {
			throw 'Both the original and target range must be array of 2 different numeric values';
		}
		value = ((value - originalRange[0]) / (originalRange[1] - originalRange[0]));
		value = (value * (targetRange[1] - targetRange[0])) + targetRange[0];

		return round ? Math.round(value) : value;
	}

	/** 
	 *	Array-wrapper for scaleValue
	*/
	static scaleValues(values, originalRange, targetRange, round = false) {
		if (!(Array.isArray(values)|| this.isMap(values)) ) {
			return this.scaleValue(values, originalRange, targetRange, round);
		}

		let arr = this.isMap(values) ? {} : [];
		for (let i in values) {
			arr[i] = (this.scaleValues(values[i], originalRange, targetRange, round));
		}
		return arr;
	}

	/**
	 *	Convenience function wrapping an array's ForEach, to return the array for in-lining'.
	 *	Operates in-place
	 */
	static forEach(array, func) {
		if ( !Array.isArray(array) ) {
			throw 'Not an array to iterate on';
		}
		if ( typeof func !== 'function' ) {
			throw 'Not a function to apply';
		}
		for( let i in array ) {
			let output = func(array[i],i,array);
			if (typeof output !== 'undefined') {
				array[i] = output;
			}	
		}
		return array;
	}
	
	static isRange(value, allowEqual = false) {
		if (!Array.isArray(value) || value.length != 2) {
			return false;
		}
		if ((!NumberUtils.isNumeric(value[0])) || (!NumberUtils.isNumeric(value[1]))) {
			return false;
		}
		return ((value[0] != value[1]) || allowEqual);
	}

	static coerceToArray(value) {
		if(value == null){
			return [];
		}
		return (!Array.isArray(value)) ? [value] : value;
	}
	static unArrayIfSingleElement(value, nullIfEmpty = true) {
		if (!Array.isArray(value)) {
			return value;
		}
		if (value.length === 1) {
			return value[0];
		}
		if (value.length === 0) {
			return nullIfEmpty ? null : value;
		}
		return value
	}
	
	static filterByArray(data, filter, func = null) {
		if ( !Array.isArray(data) ) { 
			throw new TypeError('Data must be an array');
		}
		if ( !Array.isArray(filter) ) {
			throw new TypeError('Filter must be an array');
		}
		
		if (typeof func !== 'function') {
			func = (d,f) => {return !!f};
		}
		
		let values = [];
		for ( let i=0 ; i < Math.min(data.length, filter.length) ; i++ ) {
			if (typeof func === 'function') {
				if ( func( data[i], filter[i] ) ) {
					values.push( data[i] );
				}
			}
		}
		return values;
	}
	
	/* Simple check to see if value is mapping, rather than array or primitive. For simplicity, objects are maps */
	static isMap(obj) 	{
		if (!obj) {
			// Not null or undefined
			return false;
		}
		if ( Array.isArray(obj) ) {
			// Not an array
			return false;
		}
		if ( ({}).constructor == Object(obj).constructor ) {
			// Has a generic object constructor
			return true;
		}
		return false;
	}

	static mapFromKeyValueArray(array) {
		if (this.isMatrix(array)) {
			return this.mapFromKeyValueMatrix(array);
		}

		let map = {};
		for(let i = 0 ; i < array.length ; i+=2) {
			map[array[i]] = array[i+1];
		}
		return map;
	}
	
	static mapFromKeyValueMatrix(matrix) {
		if (!this.isMatrix(matrix)) {
			return this.mapFromKeyValueArray(matrix);
		}
		
		let list = [];
		for (let i=0;i<matrix.length;i++) {
			list.push(this.mapFromKeyValueArray(matrix[i]));
		}
		
		return list;
	}
	
	static mergeMaps(concat, ...maps) {
		let newMap = {};
		
		if (maps.length === 0 ) {
			return newMap;
		}
		
		for (let key in maps[0]) {
			newMap[key] = [];
		}
		
		for (let i=0;i<maps.length;i++) {
			for (let key in newMap) {
				if (concat) {
					newMap[key] = newMap[key].concat(maps[i][key] ?? []);
				} else {
					newMap[key] = newMap[key].push(maps[i][key] ?? null);
				}
			}
		}
		return newMap;
	}
	
	static changeMapKeys(map, remapping) {
		let newMap = {};
		for (let oldKey in map) {
			newMap[remapping[oldKey]] = map[oldKey];
		}
		return newMap;
	}
	
	static flipMatrix(matrix) {
		let newMatrix = [];
		let ySize = null;
		
		for (let i = 0; i < matrix.length; i++) {
			
			ySize = ySize ?? matrix[i].length;
			
			if (matrix[i].length != ySize) {
				throw 'Matrix lengths inconsistent, could not flip';
			}
			
			for (let j = 0; j < matrix[i].length; j++) {
				
				newMatrix[j] = newMatrix[j] ?? [];
				newMatrix[j][i] = matrix[i][j];
			}
		}
		
		return newMatrix;
	}

	static clampMatrixSize(matrix, defaultValue, minSizeOuter, maxSizeOuter, minSizeInner, maxSizeInner) {
		
		let newMatrix = [];
		if (!this.isMatrix(matrix)) {
			throw new TypeError('Not a matrix');
		}
		
		for (let i = 0; i < Math.min(matrix.length, maxSizeOuter ?? matrix.length); i++) {
			
			if ((maxSizeInner ?? -1) < 0) {				
				newMatrix[i] = matrix[i];
			
			} else {				
				newMatrix[i] = matrix[i].slice(0, maxSizeInner);	
			}
			
			if (minSizeInner) {				
				newMatrix[i] = newMatrix[i].concat(Array(Math.max(0,minSizeInner - matrix[i].length)).fill(defaultValue));
			}
		}
		
		if (minSizeOuter) {
			
			for (let i = newMatrix.length; i < minSizeOuter; i++) {
				
				newMatrix[i] = new Array(minSizeInner ?? 0).fill(defaultValue);
			}
		}
		return newMatrix;
	}

	static clampMatrixSizeOuter(matrix, defaultValue, minSize, maxSize) {
		
		return this.clampMatrixSize(matrix, defaultValue, minSize, maxSize, null, null);
	}	

	static clampMatrixSizeInner(matrix, defaultValue, minSize, maxSize) {
		
		return this.clampMatrixSize(matrix, defaultValue, null, null, minSize, maxSize);
	}

	static isMatrix(matrix) {
		
		if (!Array.isArray(matrix)) {
			return false;
		}
		
		for (let inner of matrix) {
			if (!Array.isArray(inner)) {
				return false;
			}
		}
		
		return true;
	}

}

/**
* Create a rectangular MultiPolygon object
*/
function createRectangleMP(x, y, width, height) {
	return { type: "MultiPolygon", 
		coordinates: [[[
			[x, y],
			[x, y + height],
			[x + width, y + height],
			[x + width, y],
			[x, y]
		]]]
	};

}
class NumberUtils {

	static isNumeric(value) {
		return !isNaN(value*1);
	}

}



class CulvertPanel {

	static getDummyCulvert() {
		return {
			name: "-",

			datumHeight: -10000.0,
			diameter: 0,
			rectangularHeight: -10000.0,

			heights: [-10000],
			flows: [0.0],
			datumsA: [-10000.0],
			datumsB: [-10000.0],
			areaIDA: -1,
			areaIDB: -1,
			datumHeightOutputA: -10000,
			datumHeightOutputB: -10000,
			culvertN: 3 / 2,
			elevationA: -10000,
			elevationB: -10000,
		};
	}


	_addCulvertInfoElements(parent) {

		addStructureInfoLabel(parent, "Name:");
		this.culvertInfoName = addStructureInfoValue(parent, "culvertInfoName");

		addStructureInfoLabel(parent, "Threshold:");
		this.culvertInfoDatumHeight = addStructureInfoValue(parent, "culvertInfoDatumHeight");

		addStructureInfoLabel(parent, "Height:");
		this.culvertInfoRectangularHeight = addStructureInfoValue(parent, "culvertInfoRectangularHeight");

		addStructureInfoLabel(parent, "Diameter:");
		this.culvertInfoWidth = addStructureInfoValue(parent, "culvertInfoDiameter");

		addStructureInfoLabel(parent, "N:");
		this.culvertInfoN = addStructureInfoValue(parent, "culvertInfoN");

		addStructureInfoLabel(parent, "Flow:");
		this.culvertInfoFlow = addStructureInfoValue(parent, "culvertInfoFlow");

		addStructureInfoLabel(parent, "Datum A:");
		this.culvertInfoDatumA = addStructureInfoValue(parent, "culvertInfoDatumA");

		addStructureInfoLabel(parent, "Datum B:");
		this.culvertInfoDatumB = addStructureInfoValue(parent, "culvertInfoDatumB");
	
		addStructureInfoLabel(parent, "Elevation A:");
		this.culvertInfoElevationA = addStructureInfoValue(parent, "culvertInfoElevationA");

		addStructureInfoLabel(parent, "Elevation B:");
		this.culvertInfoElevationB = addStructureInfoValue(parent, "culvertInfoElevationB");

	}

	constructor(parent) {

		this.culvertDetailContainer = document.createElement("div");
		parent.appendChild(this.culvertDetailContainer);

		this.culvertInfoTitle = document.createElement("h2");
		this.culvertDetailContainer.appendChild(this.culvertInfoTitle);

		this.culvertInfoRow = document.createElement("div");
		this.culvertInfoRow.className = "water-structure-info-row-spread";

		this.culvertDetailContainer.appendChild(this.culvertInfoRow);

		this.culvertInfoDiv = document.createElement("div");
		this.culvertInfoRow.appendChild(this.culvertInfoDiv);


		this.culvertInfoColumn = document.createElement("div");
		this.culvertInfoColumn.className = "water-structure-info-grid";

		this.culvertInfoDiv.appendChild(this.culvertInfoColumn);

		this._addCulvertInfoElements(this.culvertInfoColumn);

		this.culvertCanvasColumn = document.createElement("div");
		this.culvertCanvasColumn.className = "water-structure-info-column";
		this.culvertInfoRow.appendChild(this.culvertCanvasColumn);

		this.culvertFrontCanvasDiv = document.createElement("div");
		this.culvertCanvasColumn.appendChild(this.culvertFrontCanvasDiv);

		this.culvertSideCanvasDiv = document.createElement("div");
		this.culvertCanvasColumn.appendChild(this.culvertSideCanvasDiv);

		this.culvertFrontCanvasTitle = document.createElement("h2");
		this.culvertFrontCanvasTitle.innerHTML = "Front View:";
		this.culvertFrontCanvasDiv.appendChild(this.culvertFrontCanvasTitle);

		this.culvertSideCanvasTitle = document.createElement("h2");
		this.culvertSideCanvasTitle.innerHTML = "Side View:";
		this.culvertSideCanvasDiv.appendChild(this.culvertSideCanvasTitle);

		this.culvertFrontCanvas = document.createElement("canvas");
		this.culvertFrontCanvas.width = 300;
		this.culvertFrontCanvas.height = 100;
		this.culvertFrontCanvasDiv.appendChild(this.culvertFrontCanvas);

		this.culvertSideCanvas = document.createElement("canvas");
		this.culvertSideCanvas.width = 300;
		this.culvertSideCanvas.height = 150;
		this.culvertSideCanvasDiv.appendChild(this.culvertSideCanvas);

		this.culvertSliderContainer = document.createElement("div");
		parent.appendChild(this.culvertSliderContainer);

		this.timeframeSlider = addTimeframeSlider(this.culvertSliderContainer);

		this.culvertPlotsContainer = document.createElement("div");
		this.culvertPlotRow = document.createElement("div");
		this.culvertPlotRow.className = "water-structure-info-row";

		this.culvertPlotsContainer.appendChild(this.culvertPlotRow);

		this.culvertFlowPlot = document.createElement("div");
		this.culvertFlowPlot.id = "culvertFlowPlot";
		this.culvertFlowPlot.className = "water-structure-plot";
		this.culvertPlotRow.appendChild(this.culvertFlowPlot);

		this.culvertHeightPlot = document.createElement("div");
		this.culvertHeightPlot.id = "culvertHeightPlot";
		this.culvertHeightPlot.className = "water-structure-plot";
		this.culvertPlotRow.appendChild(this.culvertHeightPlot);


		this.culvertDetailContainer.appendChild(this.culvertPlotsContainer);

	}

	updateCulvertDetailInfoPanel(culvert, culvertTimeframe) {

		if (culvert == null) {
			culvert = CulvertPanel.getDummyCulvert();
		}

		this.culvertInfoName.innerHTML = culvert.name;

		this.culvertInfoDatumHeight.innerHTML = culvert.datumHeight + " m";

		this.culvertInfoWidth.innerHTML = culvert.diameter + " m";

		this.culvertInfoRectangularHeight.innerHTML = culvert.rectangularHeight + " m";

		this.culvertInfoFlow.innerHTML = culvert.flows[culvertTimeframe] + " m³/s";

		this.culvertInfoDatumA.innerHTML = culvert.datumsA[culvertTimeframe] + " m";
		this.culvertInfoDatumB.innerHTML = culvert.datumsB[culvertTimeframe] + " m";

		this.culvertInfoElevationA.innerHTML = culvert.elevationA + " m";
		this.culvertInfoElevationB.innerHTML = culvert.elevationB + " m";

		this.culvertInfoN.innerHTML = culvert.culvertN;

	}
}


function getMinDatumCulvert(culvertDatums, datumsLeft, datumsRight) {
	let minCulvertDatum = Array.isArray(culvertDatums) ? Math.min.apply(Math, culvertDatums) : culvertDatums;
	let minDatumLeft = Array.isArray(datumsLeft) ? Math.min.apply(Math, datumsLeft) : datumsLeft;
	let minDatumRight = Array.isArray(datumsRight) ? Math.min.apply(Math, datumsRight) : datumsRight;

	return Math.min(minDatumLeft, minDatumRight, minCulvertDatum);
}


function getMaxDatumCulvert(culvertDatums, datumsLeft, datumsRight) {

	let maxCulvertDatum = Array.isArray(culvertDatums) ? Math.max.apply(Math, culvertDatums) : culvertDatums;
	let maxDatumLeft = Array.isArray(datumsLeft) ? Math.max.apply(Math, datumsLeft) : datumsLeft;
	let maxDatumRight = Array.isArray(datumsRight) ? Math.max.apply(Math, datumsRight) : datumsRight;

	return Math.max(maxDatumLeft, maxDatumRight, maxCulvertDatum);
}

function leftWaterBody(ctx, waterWidth, baseHeight, multiplier, datumLeft, minDatum) {


	let leftX = 0;
	let topY = ctx.canvas.height - (baseHeight + multiplier * (datumLeft - minDatum));

	ctx.fillStyle = getWaterGradient(ctx, topY);
	ctx.fillRect(leftX, topY, waterWidth, ctx.canvas.height);
}

function rightWaterBody(ctx, waterWidth, baseHeight, multiplier, datumRight, minDatum) {


	let leftX = ctx.canvas.width - waterWidth;
	let topY = ctx.canvas.height - (baseHeight + multiplier * (datumRight - minDatum));

	ctx.fillStyle = getWaterGradient(ctx, topY);
	ctx.fillRect(leftX, topY, waterWidth, ctx.canvas.height);
}

function drawCulvert(ctx, baseHeight, multiplier, culvertHeight) {

	let length = ctx.canvas.width * 4 / 6;
	let leftX = ctx.canvas.width / 6;
	let height = multiplier * culvertHeight;

	let topY = ctx.canvas.height - baseHeight - height;

	let culvertGradient = ctx.createLinearGradient(0, topY, 0, topY + 40);
	culvertGradient.addColorStop(0, "#dedede");
	culvertGradient.addColorStop(1, "#4a4a4a");

	ctx.beginPath();
	ctx.rect(leftX, topY, length, height);
	ctx.closePath();

	ctx.fillStyle = culvertGradient;
	ctx.fill();
	ctx.lineWidth = 1;
	ctx.strokeStyle = "black";
	ctx.stroke();
}


function drawBreakSectionDashed(ctx, midX, topY, terrainGradient) {

	let stepX = 10;
	let marginY = 10;
	ctx.fillStyle = terrainGradient;
	for (let x = midX - stepX; x <= midX + stepX; x++) {
		if (x % 4 == 0) {
			ctx.fillRect(x, topY - marginY, 2, ctx.canvas.height - marginY);
		}
	}

}

function drawBreakSection(ctx, midX, topY, terrainGradient) {

	let stepX = 10;
	let stepY = 10;
	topY -= stepY;
	let leftX = midX - stepX;
	let rightX = leftX + 2 * stepX;
	for (let fill of [true, false]) {
		let x = leftX;
		let y = topY - 10 / 2;
		ctx.beginPath();
		ctx.moveTo(x, y);

		while (y < ctx.canvas.height - stepY) {
			x = x == leftX ? x + stepX : x - stepX;
			y += stepY;
			ctx.lineTo(x, y);
		}


		x = x == leftX ? rightX : rightX + stepX;
		if (fill) {
			ctx.lineTo(x, y);
		} else {
			ctx.moveTo(x, y);
		}

		while (y > topY) {
			x = x == rightX ? x + stepX : x - stepX;
			y -= stepY;
			ctx.lineTo(x, y);
		}
		if (fill) {
			ctx.closePath();
			ctx.fillStyle = terrainGradient;
			ctx.fill();
		} else {
			ctx.lineWidth = 1;
			ctx.strokeStyle = "black";
			ctx.stroke();
		}
	}
}

function getTerrainGradient(ctx, y) {
	let envelopeGradient = ctx.createLinearGradient(0, y, 0, y + 150);
	envelopeGradient.addColorStop(0, "#b3aba1");
	envelopeGradient.addColorStop(1, "#59493c");
	return envelopeGradient;
}

function drawTerrainBox(ctx, x, y, width, height) {

	ctx.fillStyle = getTerrainGradient(ctx, y);
	ctx.fillRect(x, y, width, height);
	ctx.lineWidth = 1;
	ctx.strokeRect(x, y, width, height);
}

function drawCulvertCircle(ctx, CentrePointX, CentrePointY, Radius, Circle) {
	ctx.beginPath();
	ctx.arc(CentrePointX, CentrePointY, Radius, 0, Circle);
	ctx.fillStyle = "grey";
	ctx.fill();
	ctx.lineWidth = 6;
	ctx.stroke();
}

function drawHighWaterLevel(ctx, y, width, height) {
	ctx.rect(0, y, width, height);
	ctx.fillStyle = getWaterGradient(ctx, height);
	ctx.fill();
}

function drawLowWaterLevel(ctx, y, width, height) {
	ctx.fillStyle = getWaterGradient(ctx, height);
	ctx.fillRect(0, y, width, height);
}

function drawCulvertFront(canvas, index, culvertDatums, datumsLeft, datumsRight, culvertWidth, culvertHeight, culvertLength, culvertN) {
	if (!canvas || canvas.nodeName != "CANVAS") {
		return;
	}

	const ctx = canvas.getContext("2d");
	clearWeirContext(ctx);

	let minDatum = getMinDatumCulvert(culvertDatums, datumsLeft, datumsRight);
	let maxDatum = getMaxDatumCulvert(culvertDatums, datumsLeft, datumsRight, culvertHeight);

	let range = maxDatum - minDatum;

	let datumLeft = Array.isArray(datumsLeft) ? datumsLeft[index] : datumsLeft;
	let datumRight = Array.isArray(datumsRight) ? datumsRight[index] : datumsRight;
	let culvertDatum = Array.isArray(culvertDatums) ? culvertDatums[index] : culvertDatums;

	let baseHeight = canvas.height / 8;
	let heightMultiplier = (canvas.height - baseHeight) / range;

	//TODO: @Artist Please add draw functions
	let culvertFrontCentrePointX = ctx.canvas.width / 2;
	let culvertFrontCentrePointY = 120;
	let culvertFrontCircle = 2 * Math.PI;
	let culvertFrontRadius = 20;
	let terrainHeight = 40;
	let terrainWidth = canvas.width / 3;
	let waterWidth = canvas.width;
	let highWaterHeight = canvas.height / 2;
	let waterLevelLow = canvas.height / 1.2;
	let waterLevelHigh = canvas.height - 90

	drawHighWaterLevel(ctx, highWaterHeight, waterWidth, highWaterHeight);

	drawTerrainBox(ctx, terrainWidth, terrainHeight, terrainWidth, ctx.canvas.height);

	drawCulvertCircle(ctx, culvertFrontCentrePointX, culvertFrontCentrePointY, culvertFrontRadius, culvertFrontCircle);

	drawLowWaterLevel(ctx, waterLevelLow, waterWidth, waterLevelLow);

}

function drawCulvertSide(canvas, index, culvertDatums, datumsLeft, datumsRight, culvertDiameter, culvertRectangleHeight, elevationLeft, elevationRight) {
	if (!canvas || canvas.nodeName != "CANVAS") {
		return;
	}

	const ctx = canvas.getContext("2d");
	clearWeirContext(ctx);

	let culvertHeight = culvertRectangleHeight > 0 ? culvertRectangleHeight : culvertDiameter;

	
	//TODO: (Frank) Draw at an angle when threshold is not defined, straight at height of threshold otherwise!

	let datumLeft = Array.isArray(datumsLeft) ? datumsLeft[index] : datumsLeft;
	let datumRight = Array.isArray(datumsRight) ? datumsRight[index] : datumsRight;
	let culvertDatum = Array.isArray(culvertDatums) ? culvertDatums[index] : culvertDatums;
	culvertDatum = culvertDatums == 0 || culvertDatum == -10000 ? Math.min(elevationLeft, elevationRight) : culvertDatums;


	let minDatum = getMinDatumCulvert(culvertDatum, elevationLeft, elevationRight);
	let maxDatum = getMaxDatumCulvert(culvertDatum + culvertHeight, datumsLeft, datumsRight);

	let range = maxDatum - minDatum;


	let baseHeight = canvas.height / 8;
	let heightMultiplier = (canvas.height - 3 * baseHeight) / range;

	let waterWidth = canvas.width / 4;
	let terrainWidth = canvas.width - 2 * waterWidth;
	let terrainTopY = baseHeight / 2;

	leftWaterBody(ctx, waterWidth, baseHeight, heightMultiplier, datumLeft, minDatum);

	rightWaterBody(ctx, waterWidth, baseHeight, heightMultiplier, datumRight, minDatum);

	let terrainLeftTop = canvas.height - ((elevationLeft - Math.min(elevationLeft, elevationRight)) * heightMultiplier + baseHeight);
	let terrainRightTop = canvas.height - ((elevationRight - Math.min(elevationLeft, elevationRight)) * heightMultiplier + baseHeight);

	drawTerrainBox(ctx, 0, terrainLeftTop, waterWidth, canvas.height);
	drawTerrainBox(ctx, waterWidth, terrainTopY, terrainWidth, canvas.height);
	drawTerrainBox(ctx, canvas.width - waterWidth, terrainRightTop, waterWidth, canvas.height);



	drawCulvert(ctx, baseHeight, heightMultiplier, culvertHeight);

	let culvertTopY = ctx.canvas.height - baseHeight - heightMultiplier * culvertHeight;

	drawBreakSection(ctx, ctx.canvas.width / 2, culvertTopY, getTerrainGradient(ctx, terrainTopY));


}


function addStructureInfoLabel(parent, innerHTML) {
	let element = document.createElement("div");
	element.className = "water-structure-info-label";
	element.innerHTML = innerHTML;
	if (parent != null) {
		parent.appendChild(element);
	}
	return element;
}

function addStructureInfoValue(parent, id, innerHTML) {
	let element = document.createElement("div");
	element.className = "water-structure-info-value";
	element.id = id;
	element.innerHTML = innerHTML == null ? "" : innerHTML;
	if (parent != null) {
		parent.appendChild(element);
	}
	return element;
}




class WeirPanel {

	static getDummyWeir() {
		return {
			name: "-",
			height: [-10000.0],
			width: 0,
			flow: [0.0],
			datumA: [-10000.0],
			datumB: [-10000.0],
			damWidth: 0,
			damHeight: -1,
			areaOutputA: -1,
			areaOutputB: -1,
			angle: -10000,
			coefficient: 1.1,
			weirN: 3 / 2,
		};
	}

	_addWeirInfoElements(parent) {

		addStructureInfoLabel(parent, "Name:");
		this.weirInfoName = addStructureInfoValue(parent, "weirInfoName");

		addStructureInfoLabel(parent, "Height:");
		this.weirInfoHeight = addStructureInfoValue(parent, "weirInfoHeight");

		addStructureInfoLabel(parent, "Width:");
		this.weirInfoWidth = addStructureInfoValue(parent, "weirInfoWidth");

		addStructureInfoLabel(parent, "Angle:");
		this.weirInfoAngle = addStructureInfoValue(parent, "weirInfoAngle");

		addStructureInfoLabel(parent, "Coefficient:");
		this.weirInfoCoefficient = addStructureInfoValue(parent, "weirInfoCoefficient");

		addStructureInfoLabel(parent, "N:");
		this.weirInfoN = addStructureInfoValue(parent, "weirInfoN");

		addStructureInfoLabel(parent, "Flow:");
		this.weirInfoFlow = addStructureInfoValue(parent, "weirInfoFlow");

		addStructureInfoLabel(parent, "Datum A:");
		this.weirInfoDatumA = addStructureInfoValue(parent, "weirInfoDatumA");

		addStructureInfoLabel(parent, "Datum B:");
		this.weirInfoDatumB = addStructureInfoValue(parent, "weirInfoDatumB");

		addStructureInfoLabel(parent, "Dam Height:");
		this.weirInfoDamHeight = addStructureInfoValue(parent, "weirInfoDamHeight");

		addStructureInfoLabel(parent, "Dam Width:");
		this.weirInfoDamWidth = addStructureInfoValue(parent, "weirInfoDamWidth");

		addStructureInfoLabel(parent, "Area id A:");
		this.weirInfoAreaA = addStructureInfoValue(parent, "weirInfoAreaA");

		addStructureInfoLabel(parent, "Area id B:");
		this.weirInfoAreaB = addStructureInfoValue(parent, "weirInfoAreaB");

	}

	constructor(parent) {

		this.weirDetailContainer = document.createElement("div");
		parent.appendChild(this.weirDetailContainer);

		this.weirInfoTitle = document.createElement("h2");
		this.weirDetailContainer.appendChild(this.weirInfoTitle);
		
		this.weirInfoRow = document.createElement("div");
		this.weirInfoRow.className = "water-structure-info-row-spread";

		this.weirDetailContainer.appendChild(this.weirInfoRow);

		this.weirInfoDiv = document.createElement("div");
		this.weirInfoRow.appendChild(this.weirInfoDiv);


		this.weirInfoColumn = document.createElement("div");
		this.weirInfoColumn.className = "water-structure-info-grid";

		this.weirInfoDiv.appendChild(this.weirInfoColumn);

		this._addWeirInfoElements(this.weirInfoColumn);

		this.weirCanvasColumn = document.createElement("div");
		this.weirCanvasColumn.className = "water-structure-info-column";
		this.weirInfoRow.appendChild(this.weirCanvasColumn);

		this.weirFrontCanvasDiv = document.createElement("div");
		this.weirCanvasColumn.appendChild(this.weirFrontCanvasDiv);

		this.weirSideCanvasDiv = document.createElement("div");
		this.weirCanvasColumn.appendChild(this.weirSideCanvasDiv);

		this.weirFrontCanvasTitle = document.createElement("h2");
		this.weirFrontCanvasTitle.innerHTML = "Front View:";
		this.weirFrontCanvasDiv.appendChild(this.weirFrontCanvasTitle);

		this.weirSideCanvasTitle = document.createElement("h2");
		this.weirSideCanvasTitle.innerHTML = "Side View:";
		this.weirSideCanvasDiv.appendChild(this.weirSideCanvasTitle);

		this.weirFrontCanvas = document.createElement("canvas");
		this.weirFrontCanvas.width = 300;
		this.weirFrontCanvas.height = 100;
		this.weirFrontCanvasDiv.appendChild(this.weirFrontCanvas);

		this.weirSideCanvas = document.createElement("canvas");
		this.weirSideCanvas.width = 300;
		this.weirSideCanvas.height = 150;
		this.weirSideCanvasDiv.appendChild(this.weirSideCanvas);

		this.weirSliderContainer = document.createElement("div");
		this.weirDetailContainer.appendChild(this.weirSliderContainer);

		this.timeframeSlider = addTimeframeSlider(this.weirSliderContainer);

		this.weirPlotsContainer = document.createElement("div");
		this.weirPlotRow = document.createElement("div");
		this.weirPlotRow.className = "water-structure-info-row";

		this.weirPlotsContainer.appendChild(this.weirPlotRow);

		this.weirFlowPlot = document.createElement("div");
		this.weirFlowPlot.id = "weirFlowPlot";
		this.weirFlowPlot.className = "water-structure-plot";
		this.weirPlotRow.appendChild(this.weirFlowPlot);

		this.weirHeightPlot = document.createElement("div");
		this.weirHeightPlot.id = "weirHeightPlot";
		this.weirHeightPlot.className = "water-structure-plot";
		this.weirPlotRow.appendChild(this.weirHeightPlot);

		this.weirDetailContainer.appendChild(this.weirPlotsContainer);
	}

	updateWeirDetailInfoPanel(weir, weirTimeframe) {

		if (weir == null) {
			weir = WeirPanel.getDummyWeir();
		}

		this.weirInfoName.innerHTML = weir.name;

		this.weirInfoHeight.innerHTML = weir.heights[weirTimeframe] + " m";

		this.weirInfoWidth.innerHTML = weir.width + " m";

		this.weirInfoFlow.innerHTML = weir.flows[weirTimeframe] + " m³/s";

		this.weirInfoDatumA.innerHTML = weir.datumsA[weirTimeframe] + " m";

		this.weirInfoDatumB.innerHTML = weir.datumsB[weirTimeframe] + " m";

		this.weirInfoDamHeight.innerHTML = weir.damHeight + " m";
		this.weirInfoDamWidth.innerHTML = weir.damWidth + " m";
		this.weirInfoAreaA.innerHTML = weir.areaOutputA;
		this.weirInfoAreaB.innerHTML = weir.areaOutputB;
		this.weirInfoAngle.innerHTML = weir.angle > -10000 ? weir.angle + " &deg;" : "-";

		this.weirInfoCoefficient.innerHTML = weir.coefficient;
		this.weirInfoN.innerHTML = weir.weirN;

	}
}


function equalsCoefficient(coefficient, value) {
	return Math.abs(coefficient - value) < 0.001;
}


function drawWeirSharp(ctx, x, width, height) {

	const halfWidth = width / 2;


	ctx.beginPath();
	ctx.moveTo(x - halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height - height + width);
	ctx.lineTo(x - halfWidth, ctx.canvas.height - height);
	ctx.closePath();

	ctx.fill();
	ctx.stroke();
}

function drawWeirBroadRounded(ctx, x, width, height) {

	let radius = width / 4;
	const halfWidth = width / 2;


	ctx.beginPath();
	ctx.moveTo(x - halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height - height + radius);

	ctx.arc(x + halfWidth - radius, ctx.canvas.height - height + radius, radius, 0, 1.5 * Math.PI, true);
	ctx.lineTo(x - halfWidth + radius, ctx.canvas.height - height);

	ctx.arc(x - halfWidth + radius, ctx.canvas.height - height + radius, radius, 1.5 * Math.PI, Math.PI, true);
	ctx.lineTo(x - halfWidth, ctx.canvas.height);

	ctx.closePath();

	ctx.fill();
	ctx.stroke();

}

function drawWeirBroadPerpendicular(ctx, x, width, height) {

	const halfWidth = width / 2;

	ctx.beginPath();
	ctx.moveTo(x - halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height - height);
	ctx.lineTo(x - halfWidth, ctx.canvas.height - height);
	ctx.closePath();


	ctx.fill();
	ctx.stroke();
}

function drawWeirRounded(ctx, x, width, height) {

	let radius = width / 4;
	const halfWidth = width / 2;


	ctx.beginPath();

	ctx.moveTo(x + halfWidth, ctx.canvas.height);
	ctx.lineTo(x - halfWidth, ctx.canvas.height);
	ctx.lineTo(x - halfWidth, ctx.canvas.height - height + radius);
	ctx.arc(x - halfWidth + radius, ctx.canvas.height - height + radius, radius, Math.PI, 1.65 * Math.PI, false);

	ctx.lineTo(x + halfWidth, ctx.canvas.height - height + radius);
	ctx.closePath();

	ctx.fill();
	ctx.stroke();
}

function drawWeirRoundedRoof(ctx, x, width, height) {

	const halfWidth = width / 2;

	let xOffset = width / 4;
	let yOffset = width / 3;
	let controlLeft = x - halfWidth + xOffset;
	let controlRight = x + halfWidth - xOffset;

	ctx.beginPath();

	ctx.moveTo(x - halfWidth, ctx.canvas.height - height + yOffset);
	ctx.quadraticCurveTo(controlLeft, ctx.canvas.height - height, x, ctx.canvas.height - height);
	ctx.quadraticCurveTo(controlRight, ctx.canvas.height - height, x + halfWidth, ctx.canvas.height - height + yOffset);

	ctx.lineTo(x + halfWidth, ctx.canvas.height);
	ctx.lineTo(x - halfWidth, ctx.canvas.height);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
}

function drawWeirCustom(ctx, x, width, height) {

	let radius = width / 4;
	const halfWidth = width / 2;

	ctx.beginPath();
	ctx.moveTo(x - halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height);
	ctx.lineTo(x + halfWidth, ctx.canvas.height - height + radius);

	ctx.arc(x + halfWidth - radius, ctx.canvas.height - height + radius, radius, 0, 1.5 * Math.PI, true);
	ctx.lineTo(x - halfWidth + radius, ctx.canvas.height - height);

	ctx.arc(x - halfWidth + radius, ctx.canvas.height - height + radius, radius, 1.5 * Math.PI, Math.PI, true);
	ctx.lineTo(x - halfWidth, ctx.canvas.height);

	ctx.closePath();

	ctx.fill();
	ctx.stroke();

	ctx.font = "48px serif";
	ctx.fillStyle = "black";
	ctx.fillText("?", x - halfWidth / 2, ctx.canvas.height - height + halfWidth);
}


function drawWeirFrontVShape(ctx, weirWidth, weirHeight, weirDamWidth, weirDamHeight) {

}

function drawWeirFrontUShape(ctx, weirWidth, weirHeight, weirDamWidth, weirDamHeight) {

}

function drawWeirSideShape(ctx, x, weirThickness, height, coefficient) {

	ctx.fillStyle = getWeirGradient(ctx);
	ctx.strokeStyle = "black";

	if (equalsCoefficient(coefficient, 0.865)) {
		drawWeirBroadPerpendicular(ctx, x, weirThickness, height);

	} else if (equalsCoefficient(coefficient, 0.91)) {
		drawWeirBroadRounded(ctx, x, weirThickness, height);

	} else if (equalsCoefficient(coefficient, 1.1)) {
		drawWeirSharp(ctx, x, weirThickness, height);

	} else if (equalsCoefficient(coefficient, 1.3)) {
		drawWeirRounded(ctx, x, weirThickness, height);

	} else if (equalsCoefficient(coefficient, 1.37)) {
		drawWeirRoundedRoof(ctx, x, weirThickness, height);

	} else {
		drawWeirCustom(ctx, x, weirThickness, height);
	}
}

function drawWeirSideWaterLevels(ctx, weirThickness, baseHeight, multiplier, datumLeft, datumRight, minDatum) {

	let startX = 0;
	let startY = ctx.canvas.height - (baseHeight + multiplier * (datumLeft - minDatum));
	let drawWidth = ctx.canvas.width / 2 - weirThickness / 2;

	ctx.fillStyle = getWaterGradient(ctx, startY);
	ctx.fillRect(startX, startY, drawWidth, ctx.canvas.height);

	startX = ctx.canvas.width / 2 - weirThickness / 2
	startY = ctx.canvas.height - (baseHeight + multiplier * (datumRight - minDatum));

	ctx.fillStyle = getWaterGradient(ctx, startY);
	ctx.fillRect(startX, startY, drawWidth, ctx.canvas.height);
}

function getMinDatumWeir(weirHeights, datumsLeft, datumsRight) {
	let minWeirHeights = Array.isArray(weirHeights) ? Math.min.apply(Math, weirHeights) : weirHeights;
	let minDatumLeft = Array.isArray(datumsLeft) ? Math.min.apply(Math, datumsLeft) : datumsLeft;
	let minDatumRight = Array.isArray(datumsRight) ? Math.min.apply(Math, datumsRight) : datumsRight;

	let minDatum = Math.min(minDatumLeft, minDatumRight, minWeirHeights);
	return minDatum;
}


function getMaxDatumWeir(weirHeights, datumsLeft, datumsRight, weirDamHeight) {

	let maxWeirHeight = Array.isArray(weirHeights) ? Math.max.apply(Math, weirHeights) : weirHeights;
	let maxDatumLeft = Array.isArray(datumsLeft) ? Math.max.apply(Math, datumsLeft) : datumsLeft;
	let maxDatumRight = Array.isArray(datumsRight) ? Math.max.apply(Math, datumsRight) : datumsRight;

	let maxDatum = Math.max(maxDatumLeft, maxDatumRight, maxWeirHeight, weirDamHeight);
	return maxDatum;
}

function clearWeirContext(ctx) {
	ctx.fillStyle = "white";
	ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
}

function drawWeirSideDam(ctx, x, width, height) {

	ctx.fillStyle = getWeirDamGradient(ctx);
	ctx.strokeStyle = "black";
	drawWeirBroadPerpendicular(ctx, x, width, height);
}

function drawWeirSide(canvas, index, weirHeights, datumsLeft, datumsRight, damWidth, damHeight, flows, coefficient) {

	if (!canvas || canvas.nodeName != "CANVAS") {
		return;
	}

	const ctx = canvas.getContext("2d");
	clearWeirContext(ctx);

	if (damWidth <= 0) {
		damHeight = -10000;
	}

	let minDatum = getMinDatumWeir(weirHeights, datumsLeft, datumsRight);
	let maxDatum = getMaxDatumWeir(weirHeights, datumsLeft, datumsRight, damHeight);

	let range = maxDatum - minDatum;

	let datumLeft = Array.isArray(datumsLeft) ? datumsLeft[index] : datumsLeft;
	let datumRight = Array.isArray(datumsRight) ? datumsRight[index] : datumsRight;
	let weirHeight = Array.isArray(weirHeights) ? weirHeights[index] : weirHeights;

	if (range <= 0) {
		return;
	}

	if (damHeight <= 0) {
		damHeight = weirHeight;
	}

	let weirThickness = canvas.width / 8;
	let baseHeight = canvas.height / 8;
	let multiplier = (canvas.height - baseHeight) / range;


	let damHeightInCanvas = (baseHeight + multiplier * (damHeight - minDatum));
	drawWeirSideDam(ctx, canvas.width / 2, weirThickness, damHeightInCanvas)

	drawWeirSideWaterLevels(ctx, weirThickness, baseHeight, multiplier, datumLeft, datumRight, minDatum);

	let heightInCanvas = (baseHeight + multiplier * (weirHeight - minDatum));
	drawWeirSideShape(ctx, canvas.width / 2, weirThickness, heightInCanvas, coefficient);

}

function getWaterGradient(ctx, startY) {

	let rangeY = 100;
	let waterGradient = ctx.createLinearGradient(0, startY, 0, startY + rangeY);

	waterGradient.addColorStop(0, "rgb(0 255 255");
	waterGradient.addColorStop(1, "rgb(0 0 255");
	return waterGradient;
}

function drawFrontWaterLevel(ctx, waterLevel, minDatum, baseHeight, multiplier) {

	let startY = ctx.canvas.height - (baseHeight + multiplier * (waterLevel - minDatum));

	ctx.fillStyle = getWaterGradient(ctx, startY);
	ctx.fillRect(0, startY, ctx.canvas.width, ctx.canvas.height);
}

function getWeirGradient(ctx) {
	const weirGradient = ctx.createLinearGradient(0, 0, 0, 10);
	weirGradient.addColorStop(0, "#c7cdd8");
	weirGradient.addColorStop(1, "#cdb59f");
	return weirGradient;
}

function getWeirDamGradient(ctx) {
	const weirGradient = ctx.createLinearGradient(0, 0, 0, 10);
	weirGradient.addColorStop(0, "#e7ede8");
	weirGradient.addColorStop(1, "#ede5ef");
	return weirGradient;
}


function drawFrontWeirDam(ctx, weirWidth, weirDamWidth, weirHeight, weirDamHeight, baseHeight, minDatum, heightMultiplier, weirN) {


	let canvas = ctx.canvas;

	let widthMultiplier = canvas.width / weirDamWidth;

	let weirLeftX = canvas.width / 2 - weirWidth / 2 * widthMultiplier;
	let weirRightX = canvas.width / 2 + weirWidth / 2 * widthMultiplier;

	let weirTopY = canvas.height - (baseHeight + heightMultiplier * (weirDamHeight - minDatum));
	let weirBottomY = canvas.height - (baseHeight + heightMultiplier * (weirHeight - minDatum));

	ctx.beginPath();
	//Set start-point
	ctx.moveTo(0, canvas.height);
	// Set sub-points
	ctx.lineTo(0, weirTopY);
	ctx.lineTo(weirLeftX, weirTopY);

	if (equalsCoefficient(weirN, 5 / 3)) {

	} else {
		ctx.lineTo(weirLeftX, weirBottomY);
		ctx.lineTo(weirRightX, weirBottomY);
	}


	ctx.lineTo(weirRightX, weirTopY);
	ctx.lineTo(canvas.width, weirTopY);
	ctx.lineTo(canvas.width, canvas.height);
	ctx.closePath();
	ctx.fillStyle = getWeirGradient(ctx);
	ctx.fill();
	ctx.stroke();
}

function drawWeirFront(canvas, index, weirHeights, datumsLeft, datumsRight, weirWidth, weirDamWidth, weirDamHeight, flows, weirN) {
	if (!canvas || canvas.nodeName != "CANVAS") {
		return;
	}

	const ctx = canvas.getContext("2d");
	clearWeirContext(ctx);

	if (weirDamWidth <= 0) {
		weirDamHeight = -10000;
	}

	let minDatum = getMinDatumWeir(weirHeights, datumsLeft, datumsRight);
	let maxDatum = getMaxDatumWeir(weirHeights, datumsLeft, datumsRight, weirDamHeight);

	let range = maxDatum - minDatum;

	let datumLeft = Array.isArray(datumsLeft) ? datumsLeft[index] : datumsLeft;
	let datumRight = Array.isArray(datumsRight) ? datumsRight[index] : datumsRight;
	let weirHeight = Array.isArray(weirHeights) ? weirHeights[index] : weirHeights;

	if (weirDamWidth <= 0) {
		weirDamHeight = weirHeight;
	}

	let baseHeight = canvas.height / 8;
	let multiplier = (canvas.height - baseHeight) / range;

	let largestWaterLevel = datumLeft < datumRight ? datumRight : datumLeft;
	let smallestWaterLevel = datumLeft < datumRight ? datumLeft : datumRight;

	drawFrontWaterLevel(ctx, largestWaterLevel, minDatum, baseHeight, multiplier);

	drawFrontWeirDam(ctx, weirWidth, weirDamWidth, weirHeight, weirDamHeight, baseHeight, minDatum, multiplier, weirN);

	drawFrontWaterLevel(ctx, smallestWaterLevel, minDatum, baseHeight, multiplier);

}












// Sidebar toggles
document.querySelectorAll(".nav-item").forEach(item => {
	item.addEventListener("click", () => {
		const target = document.getElementById(item.dataset.target);
		if (!target) return;
		target.classList.toggle("open");
		item.classList.toggle("open");
	});
});

// Section switching
const allSections = document.querySelectorAll(".section");
const subItems = document.querySelectorAll(".sub-item");

subItems.forEach(btn => {
	btn.addEventListener("click", () => {
		subItems.forEach(s => s.classList.remove("active"));
		btn.classList.add("active");

		const id = btn.dataset.section;
		allSections.forEach(sec => sec.classList.remove("active"));
		document.getElementById(id).classList.add("active");
	});
});

// Default open
document.querySelectorAll(".nav-item").forEach(item => item.click());

document.querySelector("[data-section='wb-volumetabel']").click();

document.getElementById("waterAreaName").innerHTML = '$NAME';


const queries = new QueryDataManager();
const stepwise = (value, index, array) => index === 0 ? value : value - array[index - 1];
const countPositive = value => Math.max(0, value);
const countNegative = value => Math.abs(Math.min(0, value));

const data = {};

const TIMEFRAMES = 'timeframes';
const TIMEFRAMETIMES = 'timeframetimes';
queries.addQuery(TIMEFRAMETIMES,
	'$SELECT_NAME_WHERE_TIMEFRAME_IS_X_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');

data[TIMEFRAMETIMES] = queries.getData(TIMEFRAMETIMES);
data[TIMEFRAMES] = data[TIMEFRAMETIMES].map((_value, index) => index);
const timeframes = data[TIMEFRAMES].length;
var timeframe = timeframes - 1;

/**
 * WEIRS
 */

function updateWeirDetails(weir) {

	if (weir == null) {
		weir = getDummyWeir();
	}

	weirPanel.updateWeirDetailInfoPanel(weir, weirTimeframe);

	drawWeirSide(weirPanel.weirSideCanvas, weirTimeframe, weir.heights, weir.datumsA, weir.datumsB,  weir.damWidth, weir.damHeight, weir.flows, weir.coefficient);
	drawWeirFront(weirPanel.weirFrontCanvas, weirTimeframe, weir.heights, weir.datumsA, weir.datumsB, weir.width, weir.damWidth, weir.damHeight, weir.flows, weir.n);

	updateWeirFlowPlot(weir);

	updateWeirHeightPlot(weir);

}

function updateWeirFlowPlot(weir) {

	let properties = [HSO_OVERLAY_TIMEFRAMES, WEIR_FLOW_OUTPUT];
	let colors = {};
	colors[WEIR_FLOW_OUTPUT] = [218, 10, 10, 0.5];

	let titles = {};
	titles[WEIR_FLOW_OUTPUT] = "Flow";

	let data = {};
	let dataTimeframes = [];
	for (let t = 0; t < timeframes; t++) {
		dataTimeframes.push(t);
	}
	data[HSO_OVERLAY_TIMEFRAMES] = dataTimeframes;
	data[WEIR_FLOW_OUTPUT] = weir.flows;

	let layout = createWeirPlotLayout();
	layout.title = {
		text: "Flow (m³/s)"
	};
	xyPlot(weirPanel.weirFlowPlot, "scatter", data, properties, colors, titles, layout);
}

function createWeirPlotLayout() {

	layout = createLayout();
	layout.showLegend = true;
	layout.width = 300;
	layout.height = 200;
	layout.margin = { l: 40, r: 40, t: 40, b: 40 };
	return layout;
}

function updateWeirHeightPlot(weir) {

	let properties = [HSO_OVERLAY_TIMEFRAMES, WEIR_HEIGHT_OUTPUT, WEIR_DATUM_OUTPUT_A, WEIR_DATUM_OUTPUT_B];
	let colors = {};
	colors[WEIR_HEIGHT_OUTPUT] = [218, 10, 10, 0.5];
	colors[WEIR_DATUM_OUTPUT_A] = [10, 218, 10, 0.5];
	colors[WEIR_DATUM_OUTPUT_B] = [10, 10, 218, 0.5];

	let titles = {};
	titles[WEIR_HEIGHT_OUTPUT] = "Height";
	titles[WEIR_DATUM_OUTPUT_A] = "Datum A"; // replace A with water level area name
	titles[WEIR_DATUM_OUTPUT_B] = "Datum B"; // replace B with water level area name

	let data = {};
	let dataTimeframes = [];
	for (let t = 0; t < timeframes; t++) {
		dataTimeframes.push(t);
	}
	data[HSO_OVERLAY_TIMEFRAMES] = dataTimeframes;
	data[WEIR_HEIGHT_OUTPUT] = weir.heights;
	data[WEIR_DATUM_OUTPUT_A] = weir.datumsA;
	data[WEIR_DATUM_OUTPUT_B] = weir.datumsB;

	let layout = createWeirPlotLayout();
	layout.title = {
		text: "Height and Datum (m)"
	};
	xyPlot(weirPanel.weirHeightPlot, "scatter", data, properties, colors, titles, layout);
}

function selectWeir(index) {
	let weirInfoTitle = weirPanel.weirInfoTitle;

	let weir = index >= 0 && index < weirs.length ? weirs[index] : null;

	if (weir == null) {
		weirInfoTitle.innerHTML = "-";
		updateWeirDetails(weir);
		return;
	}


	weirInfoTitle.innerHTML = weir.name;
	updateWeirDetails(weir);

	let weirList = document.getElementById("weirList");
	for (item of weirList.children) {
		if (item.myIndex == index) {
			item.classList.add('selected');
		} else {
			item.classList.remove('selected');
		}
	}
}

function getSelectedWeirIndex() {
	for (item of document.getElementById("weirList").children) {
		if (item.classList.contains('selected')) {
			return item.myIndex;
		}
	}
	return 0;
}

function addWeirListItem(index) {
	let weirList = document.getElementById("weirList");


	let listItem = document.createElement("a");
	listItem.onclick = () => selectWeir(index);
	listItem.innerHTML = weirs[index].name;
	listItem.myIndex = index;

	weirList.appendChild(listItem);

};

const HSO_OVERLAY_TIMEFRAMES = "hso_overlay_timeframes";
const WEIR_NAMES = 'weir_name';
const WEIR_HEIGHTS = 'weir_heights';
const WEIR_WIDTH = 'weir_width';
const WEIR_FLOW_OUTPUT = 'weir_flow_output';
const WEIR_HEIGHT_OUTPUT = 'weir_height_output';
const WEIR_DATUM_OUTPUT_A = 'weir_datum_output_a';
const WEIR_DATUM_OUTPUT_B = 'weir_datum_output_b';
const WEIR_DAM_WIDTH = 'weir_dam_width';
const WEIR_DAM_HEIGHT = 'weir_dam_height';
const WEIR_AREA_OUTPUT_A = 'weir_water_area_output_a';
const WEIR_AREA_OUTPUT_B = 'weir_water_area_output_b';
const WEIR_ANGLE = 'weir_angle';
const WEIR_COEFFICIENT = 'weir_coefficient';
const WEIR_N = 'weir_n';

queries.addQuery(WEIR_NAMES, '$SELECT_NAME_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(WEIR_HEIGHTS, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_WEIR_HEIGHT_AND_TIMEFRAME_IS_X');
queries.addQuery(WEIR_WIDTH, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_WEIR_WIDTH');
queries.addQuery(WEIR_HEIGHT_OUTPUT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_HEIGHT_OUTPUT_AND_TIMEFRAME_IS_X');
queries.addQuery(WEIR_FLOW_OUTPUT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_FLOW_OUTPUT_AND_TIMEFRAME_IS_X');
queries.addQuery(WEIR_DATUM_OUTPUT_A, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_DATUM_OUTPUT_A_AND_TIMEFRAME_IS_X');
queries.addQuery(WEIR_DATUM_OUTPUT_B, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_DATUM_OUTPUT_B_AND_TIMEFRAME_IS_X');
queries.addQuery(WEIR_DAM_WIDTH, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_WEIR_DAM_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(WEIR_DAM_HEIGHT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_WEIR_DAM_OUTPUT_AND_INDEX_IS_1');
queries.addQuery(WEIR_AREA_OUTPUT_A, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(WEIR_AREA_OUTPUT_B, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_1');
queries.addQuery(WEIR_ANGLE, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_WEIR_ANGLE');
queries.addQuery(WEIR_COEFFICIENT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_WEIR_COEFFICIENT');
queries.addQuery(WEIR_N, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_WEIR_N');

const WEIR_PARAM_PROPERTIES = ["name", "coefficient", "weirN", "heights", "width", "angle", "damWidth", "damHeight"];
const WEIR_PARAM_TITLES = {
	"name": "Name",
	"coefficient": "Coefficient",
	"weirN": "Weir N",
	"heights": "Height (m)",
	"width": "Width (m)",
	"angle": "Angle (°)",
	"damWidth": "Dam Width (m)",
	"damHeight": "Dam Height (m)"
}

const WEIR_RESULT_PROPERTIES = ["name", "flows", "heights", "datumsA", "datumsB", "areaOutputA", "areaOutputB"];
const WEIR_RESULT_TITLES = {
	"name": WEIR_PARAM_TITLES["name"],
	"flows": "Flow (M³/s)",
	"heights": "Height (m)",
	"datumsA": "Datum A (m)",
	"datumsB": "Datum B (m)",
	"areaOutputA": "Area ID A",
	"areaOutputB": "Area ID B",

}
let weirTimeframe = 0;

function createWeirs() {

	let weirs = [];

	let names = queries.getData(WEIR_NAMES, true);
	let width = queries.getData(WEIR_WIDTH, true);
	let heights = queries.getData(WEIR_HEIGHT_OUTPUT, true);
	let flow = queries.getData(WEIR_FLOW_OUTPUT, true);
	let datumA = queries.getData(WEIR_DATUM_OUTPUT_A, true);
	let datumB = queries.getData(WEIR_DATUM_OUTPUT_B, true);
	let damWidth = queries.getData(WEIR_DAM_WIDTH, true);
	let damHeight = queries.getData(WEIR_DAM_HEIGHT, true);
	let areaOutputA = queries.getData(WEIR_AREA_OUTPUT_A, true);
	let areaOutputB = queries.getData(WEIR_AREA_OUTPUT_B, true);
	let angle = queries.getData(WEIR_ANGLE, true);
	let coefficient = queries.getData(WEIR_COEFFICIENT, true);
	let weirN = queries.getData(WEIR_N, true);

	for (let i = 0; i < names.length; i++) {

		let weir = {
			name: i < names.length ? names[i] : "Weir " + i,

			// array values
			heights: i < heights.length ? heights[i] : Array(timeframes).fill(-10000),
			flows: i < flow.length ? flow[i] : Array(timeframes).fill(0),
			datumsA: i < datumA.length ? datumA[i] : Array(timeframes).fill(-10000),
			datumsB: i < datumB.length ? datumB[i] : Array(timeframes).fill(-10000),

			// single value
			width: i < width.length ? width[i][0] : 0,
			damWidth: i < damWidth.length ? damWidth[i][0] : 0,
			damHeight: i < damHeight.length ? damHeight[i][0] : -1,
			areaOutputA: i < areaOutputA.length ? areaOutputA[i][0] : -1,
			areaOutputB: i < areaOutputB.length ? areaOutputB[i][0] : -1,
			angle: i < angle.length ? angle[i][0] : -10000,
			coefficient: i < coefficient.length && coefficient[i][0] > 0 ? coefficient[i][0] : 1.1,
			weirN: i < weirN.length && weirN[i][0] > 0 ? weirN[i][0] : 3 / 2,
		};
		weirs.push(weir);

	}

	return weirs;
}

function updateWeirList(weirs) {
	removeAllChildren(document.getElementById("weirList"));

	for (let i = 0; i < weirs.length; i++) {
		addWeirListItem(i);
	}

	if (weirs.length > 0) {
		selectWeir(0, weirTimeframe);
	}
}

function fillWeirTables(weirs, timeframe) {
	fillWeirParamTable(weirs, timeframe);
	fillWeirResultTable(weirs, timeframe);
}

function fillWeirParamTable(weirs, timeframe) {

	let paramTable = document.getElementById("weirParamTable");

	clearTable(paramTable);

	addHeaderRow(paramTable, WEIR_PARAM_PROPERTIES, WEIR_PARAM_TITLES);
	for (let weir of weirs) {
		addTimeframeRow(paramTable, timeframe, weir, WEIR_PARAM_PROPERTIES, {});
	}
}

function fillWeirResultTable(weirs, timeframe) {

	let resultTable = document.getElementById("weirResultsTable");

	clearTable(resultTable);

	addHeaderRow(resultTable, WEIR_RESULT_PROPERTIES, WEIR_RESULT_TITLES);
	for (let weir of weirs) {
		addTimeframeRow(resultTable, timeframe, weir, WEIR_RESULT_PROPERTIES, {});
	}
}

const weirPanel = new WeirPanel(document.getElementById("weirDetailParent"));
setupTimeframeSlider(weirPanel.timeframeSlider, weirTimeframe, timeframes, function() {
	weirTimeframe = weirPanel.timeframeSlider.style.getPropertyValue("--value");
	selectWeir(getSelectedWeirIndex());
});

const weirs = createWeirs();
fillWeirTables(weirs, weirTimeframe);
updateWeirList(weirs);

const weirResultSlider = addTimeframeSlider(document.getElementById("weirResultSliderDiv"));
const weirParamSlider = addTimeframeSlider(document.getElementById("weirParamSliderDiv"));
setupTimeframeSlider(weirParamSlider, weirTimeframe, timeframes, function() {
	let timeframe = weirParamSlider.style.getPropertyValue("--value");
	weirResultSlider.style.setProperty("--value", timeframe);
	fillWeirTables(weirs, timeframe);
});
setupTimeframeSlider(weirResultSlider, weirTimeframe, timeframes, function() {
	let timeframe = weirResultSlider.style.getPropertyValue("--value");
	weirParamSlider.style.setProperty("--value", timeframe);
	fillWeirTables(weirs, timeframe);
});

addDownloadHandler(document.getElementById("weirDownloadParamCsvButton"), "weir_params.csv", () => toCSVContent(weirs, WEIR_PARAM_PROPERTIES, WEIR_PARAM_TITLES, timeframes));
addDownloadHandler(document.getElementById("weirDownloadResultCsvButton"), "weir_results.csv", () => toCSVContent(weirs, WEIR_RESULT_PROPERTIES, WEIR_RESULT_TITLES, timeframes));

if (weirs.length <= 0) {
	document.getElementById("navGroupWeirs").style.display = 'none';
}

/**
 * CULVERTS
 */
function updateCulvertDetails(culvert) {

	if (culvert == null) {
		culvert = getDummyCulvert();
	}

	culvertPanel.updateCulvertDetailInfoPanel(culvert, culvertTimeframe);

	drawCulvertSide(culvertPanel.culvertSideCanvas, culvertTimeframe, culvert.datumHeight, culvert.datumsA, culvert.datumsB,
		culvert.diameter, culvert.rectangularHeight, culvert.elevationA, culvert.elevationB);
	drawCulvertFront(culvertPanel.culvertFrontCanvas, culvertTimeframe, culvert.datumHeight, culvert.datumsA, culvert.datumsB, culvert.diameter, culvert.rectangularHeight, 1, culvert.culvertN);

	updateCulvertFlowPlot(culvert);

	updateCulvertHeightPlot(culvert);

}

function updateCulvertFlowPlot(culvert) {

	let properties = [HSO_OVERLAY_TIMEFRAMES, CULVERT_FLOW_OUTPUT];
	let colors = {};
	colors[CULVERT_FLOW_OUTPUT] = [218, 10, 10, 0.5];

	let titles = {};
	titles[CULVERT_FLOW_OUTPUT] = "Flow";

	let data = {};
	let dataTimeframes = [];
	for (let t = 0; t < timeframes; t++) {
		dataTimeframes.push(t);
	}
	data[HSO_OVERLAY_TIMEFRAMES] = dataTimeframes;
	data[CULVERT_FLOW_OUTPUT] = culvert.flows;

	let layout = createWeirPlotLayout();
	layout.title = {
		text: "Flow (m³/s)"
	};
	xyPlot(culvertPanel.culvertFlowPlot, "scatter", data, properties, colors, titles, layout);
}
function updateCulvertHeightPlot(culvert) {

	let properties = [HSO_OVERLAY_TIMEFRAMES, CULVERT_HEIGHT_OUTPUT, CULVERT_DATUM_OUTPUT_A, CULVERT_DATUM_OUTPUT_B];
	let colors = {};
	colors[CULVERT_HEIGHT_OUTPUT] = [218, 10, 10, 0.5];
	colors[CULVERT_DATUM_OUTPUT_A] = [10, 218, 10, 0.5];
	colors[CULVERT_DATUM_OUTPUT_B] = [10, 10, 218, 0.5];

	let titles = {};
	titles[CULVERT_HEIGHT_OUTPUT] = "Height";
	titles[CULVERT_DATUM_OUTPUT_A] = "Datum A"; // replace A with water level area name
	titles[CULVERT_DATUM_OUTPUT_B] = "Datum B"; // replace B with water level area name

	let data = {};
	let dataTimeframes = [];
	for (let t = 0; t < timeframes; t++) {
		dataTimeframes.push(t);
	}
	data[HSO_OVERLAY_TIMEFRAMES] = dataTimeframes;
	data[CULVERT_HEIGHT_OUTPUT] = culvert.heights;
	data[CULVERT_DATUM_OUTPUT_A] = culvert.datumsA;
	data[CULVERT_DATUM_OUTPUT_B] = culvert.datumsB;

	let layout = createWeirPlotLayout();
	layout.title = {
		text: "Height and Datum (m)"
	};
	xyPlot(culvertPanel.culvertHeightPlot, "scatter", data, properties, colors, titles, layout);
}

function selectCulvert(index) {
	let culvertInfoTitle = culvertPanel.culvertInfoTitle;

	let culvert = index >= 0 && index < culverts.length ? culverts[index] : null;

	if (culvert == null) {
		culvertInfoTitle.innerHTML = "-";
		updateCulvertDetails(culvert);
		return;
	}


	culvertInfoTitle.innerHTML = culvert.name;
	updateCulvertDetails(culvert);

	let culvertList = document.getElementById("culvertList");
	for (item of culvertList.children) {
		if (item.myIndex == index) {
			item.classList.add('selected');
		} else {
			item.classList.remove('selected');
		}
	}
}

function getSelectedCulvertIndex() {
	for (item of document.getElementById("culvertList").children) {
		if (item.classList.contains('selected')) {
			return item.myIndex;
		}
	}
	return 0;
}

function addCulvertListItem(index) {
	let culvertList = document.getElementById("culvertList");


	let listItem = document.createElement("a");
	listItem.onclick = () => selectCulvert(index);
	listItem.innerHTML = culverts[index].name;
	listItem.myIndex = index;

	culvertList.appendChild(listItem);

};

const CULVERT_NAMES = 'culvert_name';
const CULVERT_DIAMETER = 'culvert_diameter';
const CULVERT_DATUM_HEIGHT = 'culvert_heights';
const CULVERT_RECTANGULAR_HEIGHT = 'culvert_width';
const CULVERT_FLOW_OUTPUT = 'culvert_flow_output';
const CULVERT_HEIGHT_OUTPUT = 'culvert_height_output';
const CULVERT_DATUM_OUTPUT_A = 'culvert_datum_output_a';
const CULVERT_DATUM_OUTPUT_B = 'culvert_datum_output_b';
const CULVERT_DATUM_HEIGHT_OUTPUT_A = 'culvert_datum_height_output_a';
const CULVERT_DATUM_HEIGHT_OUTPUT_B = 'culvert_datum_height_output_b';
const CULVERT_AREA_OUTPUT_A = 'culvert_water_area_output_a';
const CULVERT_AREA_OUTPUT_B = 'culvert_water_area_output_b';
const CULVERT_N = 'culvert_n';

queries.addQuery(CULVERT_NAMES, '$SELECT_NAME_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(CULVERT_DIAMETER, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_CULVERT_DIAMETER');
queries.addQuery(CULVERT_N, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_CULVERT_N');
queries.addQuery(CULVERT_DATUM_HEIGHT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_CULVERT_THRESHOLD');
queries.addQuery(CULVERT_RECTANGULAR_HEIGHT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_CULVERT_RECTANGULAR_HEIGHT');
queries.addQuery(CULVERT_HEIGHT_OUTPUT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_HEIGHT_OUTPUT_AND_TIMEFRAME_IS_X');
queries.addQuery(CULVERT_FLOW_OUTPUT, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_FLOW_OUTPUT_AND_TIMEFRAME_IS_X');
queries.addQuery(CULVERT_DATUM_OUTPUT_A, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_DATUM_OUTPUT_A_AND_TIMEFRAME_IS_X');
queries.addQuery(CULVERT_DATUM_OUTPUT_B, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_DATUM_OUTPUT_B_AND_TIMEFRAME_IS_X');
queries.addQuery(CULVERT_AREA_OUTPUT_A, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(CULVERT_AREA_OUTPUT_B, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_1');
queries.addQuery(CULVERT_DATUM_HEIGHT_OUTPUT_A, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_4');
queries.addQuery(CULVERT_DATUM_HEIGHT_OUTPUT_B, '$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_YK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_5');

const CULVERT_PARAM_PROPERTIES = ["name", "diameter", "rectangularHeight", "datumHeight", "culvertN"];
const CULVERT_PARAM_TITLES = {
	"name": "Name",
	"diameter": "Diameter (m)",
	"rectangularHeight": "Rectangular Height (m)",
	"datumHeight": "Datum Height (m)",
	"culvertN": "Culvert N",
}

const CULVERT_RESULT_PROPERTIES = ["name", "flows", "heights", "datumsA", "datumsB", "areaIDA", "areaIDB", "datumHeightOutputA", "datumHeightOutputB"];
const CULVERT_RESULT_TITLES = {
	"name": CULVERT_PARAM_TITLES["name"],
	"flows": "Flow (M³/s)",
	"heights": "Height (m)",
	"datumsA": "Water Level Datum A (m)",
	"datumsB": "Water Level Datum B (m)",
	"areaIDA": "Area ID A",
	"areaIDB": "Area ID B",
	"datumHeightOutputA": "Datum Elevation A (m)",
	"datumHeightOutputB": "Datum Elevation B (m)",

}
let culvertTimeframe = 0;

function createCulverts() {

	let culverts = [];

	let names = queries.getData(CULVERT_NAMES, true);
	let diameters = queries.getData(CULVERT_DIAMETER, true);
	let datumHeights = queries.getData(CULVERT_DATUM_HEIGHT, true);
	let rectangularHeights = queries.getData(CULVERT_RECTANGULAR_HEIGHT, true);
	let culvertNs = queries.getData(CULVERT_N, true);
	let heights = queries.getData(CULVERT_HEIGHT_OUTPUT, true);
	let flows = queries.getData(CULVERT_FLOW_OUTPUT, true);
	let datumsA = queries.getData(CULVERT_DATUM_OUTPUT_A, true);
	let datumsB = queries.getData(CULVERT_DATUM_OUTPUT_B, true);
	let areaIDA = queries.getData(CULVERT_AREA_OUTPUT_A, true);
	let areaIDB = queries.getData(CULVERT_AREA_OUTPUT_B, true);
	let elevationA = queries.getData(CULVERT_DATUM_HEIGHT_OUTPUT_A, true);
	let elevationB = queries.getData(CULVERT_DATUM_HEIGHT_OUTPUT_B, true);

	for (let i = 0; i < names.length; i++) {

		let culvert = {

			name: i < names.length ? names[i] : "Culvert " + i,

			// array values
			heights: i < heights.length ? heights[i] : Array(timeframes).fill(-10000),
			flows: i < flows.length ? flows[i] : Array(timeframes).fill(0),
			datumsA: i < datumsA.length ? datumsA[i] : Array(timeframes).fill(-10000),
			datumsB: i < datumsB.length ? datumsB[i] : Array(timeframes).fill(-10000),

			// single value
			datumHeight: i < datumHeights.length ? datumHeights[i][0] : -10000.0,
			diameter: i < diameters.length ? diameters[i][0] : 0,
			rectangularHeight: i < rectangularHeights.length ? rectangularHeights[i][0] : -10000.0,
			culvertN: i < culvertNs.length && culvertNs[i][0] > 0 ? culvertNs[i][0] : 3 / 2,

			areaIDA: i < areaIDA.length ? areaIDA[i][0] : -1,
			areaIDB: i < areaIDB.length ? areaIDB[i][0] : -1,
			elevationA: i < elevationA.length ? elevationA[i][0] : -10000,
			elevationB: i < elevationB.length ? elevationB[i][0] : -10000,
		};
		culverts.push(culvert);

	}

	return culverts;
}

function updateCulvertList(culverts) {
	removeAllChildren(document.getElementById("culvertList"));

	for (let i = 0; i < culverts.length; i++) {
		addCulvertListItem(i);
	}

	if (culverts.length > 0) {
		selectCulvert(0, culvertTimeframe);
	}
}

function fillCulvertTables(culverts, timeframe) {
	fillCulvertParamTable(culverts, timeframe);
	fillCulvertResultTable(culverts, timeframe);
}

function fillCulvertParamTable(culverts, timeframe) {

	let paramTable = document.getElementById("culvertParamTable");

	clearTable(paramTable);

	addHeaderRow(paramTable, CULVERT_PARAM_PROPERTIES, CULVERT_PARAM_TITLES);
	for (let culvert of culverts) {
		addTimeframeRow(paramTable, timeframe, culvert, CULVERT_PARAM_PROPERTIES, {});
	}
}

function fillCulvertResultTable(culverts, timeframe) {

	let resultTable = document.getElementById("culvertResultsTable");

	clearTable(resultTable);

	addHeaderRow(resultTable, CULVERT_RESULT_PROPERTIES, CULVERT_RESULT_TITLES);
	for (let culvert of culverts) {
		addTimeframeRow(resultTable, timeframe, culvert, CULVERT_RESULT_PROPERTIES, {});
	}
}

const culvertPanel = new CulvertPanel(document.getElementById("culvertDetailParent"));
setupTimeframeSlider(culvertPanel.timeframeSlider, culvertTimeframe, timeframes, function() {
	culvertTimeframe = culvertPanel.timeframeSlider.style.getPropertyValue("--value");
	selectCulvert(getSelectedCulvertIndex());
});

const culverts = createCulverts();
fillCulvertTables(culverts, culvertTimeframe);
updateCulvertList(culverts);

const culvertResultSlider = addTimeframeSlider(document.getElementById("culvertResultSliderDiv"));
const culvertParamSlider = addTimeframeSlider(document.getElementById("culvertParamSliderDiv"));
setupTimeframeSlider(culvertParamSlider, culvertTimeframe, timeframes, function() {
	let timeframe = culvertParamSlider.style.getPropertyValue("--value");
	culvertResultSlider.style.setProperty("--value", timeframe);
	fillCulvertTables(culverts, timeframe);
});
setupTimeframeSlider(culvertResultSlider, culvertTimeframe, timeframes, function() {
	let timeframe = culvertResultSlider.style.getPropertyValue("--value");
	culvertParamSlider.style.setProperty("--value", timeframe);
	fillCulvertTables(culverts, timeframe);
});

addDownloadHandler(document.getElementById("culvertDownloadParamCsvButton"), "culvert_params.csv", () => toCSVContent(culverts, CULVERT_PARAM_PROPERTIES, CULVERT_PARAM_TITLES, timeframes));
addDownloadHandler(document.getElementById("culvertDownloadResultCsvButton"), "culvert_results.csv", () => toCSVContent(culverts, CULVERT_RESULT_PROPERTIES, CULVERT_RESULT_TITLES, timeframes));
//addImportHandler(document.getElementById("culvertImportResultCsvButton"),culverts, data[TIMEFRAMETIMES]);

if (culverts.length <= 0) {
	document.getElementById("navGroupCulverts").style.display = 'none';
}
/**
 * Volume section 
 */
const M3TOTAL = 'm3Total';
const M3LAND = 'm3Land';
const M3WATER = 'm3Water';
const M3SEWER = 'm3Sewer';
const M3UNSATURATED = 'm3Unsaturated';
const M3SATURATED = 'm3Saturated';
const M3STORAGE = 'm3Storage';
const M3GROUND = 'm3Ground';

queries.addQuery(M3TOTAL,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_SURFACE_LAST_VALUE');
queries.addQuery(M3GROUND,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_GROUND_LAST_STORAGE');
queries.addQuery(M3STORAGE,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_BUILDING_LAST_STORAGE');
queries.addQuery(M3SEWER,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_SEWER_LAST_VALUE');
queries.addQuery(M3UNSATURATED,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_GROUND_LAST_UNSATURATED_STORAGE');
queries.addQuery(M3WATER,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_M3WATER_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID');

for (property of [M3TOTAL, M3WATER, M3GROUND, M3STORAGE, M3SEWER, M3UNSATURATED]) {
	data[property] = queries.getData(property);
}

data[M3SATURATED] = data[M3GROUND].map((value, index) => value - data[M3UNSATURATED][index])
data[M3LAND] = data[M3TOTAL].map((value, index) => value - data[M3WATER][index]);

function initVolumeTitles() {
	let titles = {};

	titles[TIMEFRAMES] = "Timeframe";//"Timeframe";
	titles[TIMEFRAMETIMES] = "Timestamp";//"Tijdstap";
	titles[M3LAND] = "Water on land [m³]";// "Water op land [m³]";
	titles[M3WATER] = "Surface water [m³]";//"Oppervlaktewater [m³]";
	titles[M3GROUND] = "Groundwater [m³]";//"Grondwater [m³]";
	titles[M3STORAGE] = "Building storage [m³]";//"Waterbergende voorzieningen [m³]";
	titles[M3SEWER] = "Sewer storage [m³]";//"Rioolwater [m³]";
	titles[M3UNSATURATED] = "Storage unsaturated zone [m³]";//"Berging onverzadidge zone [m³]";
	titles[M3SATURATED] = "Storage saturated zone [m³]";//"Berging verzadidge zone [m³]";

	return titles;
}

function initVolumeColors() {
	let colors = {};

	colors[M3WATER] = [10, 10, 218, 0.5];
	colors[M3LAND] = [10, 218, 10, 0.5];
	colors[M3GROUND] = [165, 42, 42, 0.5];
	colors[M3STORAGE] = [218, 10, 10, 0.5];
	colors[M3SEWER] = [128, 128, 128, 0.5];
	colors[M3UNSATURATED] = [218, 165, 10, 0.5];
	colors[M3SATURATED] = [10, 165, 165, 0.5];

	return colors;
}

const properties = [TIMEFRAMES, TIMEFRAMETIMES, M3LAND, M3WATER, M3SATURATED, M3UNSATURATED, M3SEWER, M3STORAGE];
const plotProperties = [TIMEFRAMES, M3LAND, M3WATER, M3SATURATED, M3UNSATURATED, M3SEWER, M3STORAGE];

const volumeTitles = initVolumeTitles();
const volumeColors = initVolumeColors();

createTable("waterBalanceTable", data, properties, volumeColors, volumeTitles);

const barPlotLayout = createBarPlotLayout();
barPlotLayout.title.text = "Berging per component";
barPlotLayout.yaxis.title.text = "Volume [m³]";
barPlotLayout.xaxis.title.text = "Component";

const barSlider = addTimeframeSlider(document.getElementById("balanceSliderDiv"));

function updateBarPlot() {
	barPlot("balancePlot", data, barSlider.getValue(), plotProperties, volumeColors, volumeTitles, barPlotLayout);
}

updateBarPlot();
setupTimeframeSlider(barSlider, timeframe, timeframes, updateBarPlot);


/**
 * Flow section 
 */
const MODEL_IN = 'MODEL_IN';
const MODEL_OUT = 'MODEL_OUT';
const RAINM3 = 'RAINM3';
const RAINM3LAND = 'RAINM3LAND';
const RAINM3WATER = 'RAINM3WATER';
const RAINM3STORAGE = 'RAINM3STORAGE';

const LANDSEWER = 'LANDSEWER';

const EVAPOTRANSPIRATION = 'EVAPOTRANSPIRATION';
const BOTTOM_FLOW = "BOTTOM_FLOW";
const GROUND_TRANSPIRATION = 'GROUND_TRANSPIRATION';
const SURFACE_EVAPORATIONLAND = 'SURFACE_EVAPORATIONLAND';
const SURFACE_EVAPORATIONWATER = 'SURFACE_EVAPORATIONWATER';

const SEWER_POC = 'SEWER_POC';
const SEWER_OVERFLOW_OUT = 'SEWER_OVERFLOW_OUT';

const INLET_SURFACE = 'INLET_SURFACE';
const INLET_GROUND = 'INLET_GROUND';
const OUTLET_SURFACE = "OUTLET_SURFACE";
const OUTLET_GROUND = "OUTLET_GROUND";
const BOTTOM_FLOW_IN = "BOTTOM_FLOW_IN";
const BOTTOM_FLOW_OUT = "BOTTOM_FLOW_OUT";
const CULVERT = "CULVERT";
const CULVERT_IN = "CULVERT_IN";
const CULVERT_OUT = "CULVERT_OUT";
const CULVERT_INNER = "CULVERT_INNER";
const PUMP = "PUMP";
const PUMP_IN = "PUMP_IN";
const PUMP_OUT = "PUMP_OUT";
const PUMP_INNER = "PUMP_INNER";
const WEIR = "WEIR";
const WEIR_IN = "WEIR_IN";
const WEIR_OUT = "WEIR_OUT";
const WEIR_INNER = "WEIR_INNER";
const BREACH = "BREACH";
const BREACH_IN = "BREACH_IN";
const BREACH_OUT = "BREACH_OUT";

function initFlowTitles() {

	let flowTitles = {};
	flowTitles[TIMEFRAMES] = "Timeframes";
	flowTitles[TIMEFRAMETIMES] = "Timestamp";//"Tijdstap";

	flowTitles[RAINM3] = 'Rainfall [m³/timeframe]';//'Neerslag [m³/tijdstap]';
	flowTitles[RAINM3LAND] = 'Rainfall on land [m³/timeframe]';// 'Neerslag op land [m³/tijdstap]';
	flowTitles[RAINM3WATER] = 'Rainfall on water [m³/timeframe]';//'Neerslag op water [m³/tijdstap]';
	flowTitles[RAINM3STORAGE] = 'Rainfall on building storage [m³/timeframe]';//'Neerslag op bergende voorzieningen [m³/tijdstap]';
	flowTitles[LANDSEWER] = 'Sewer in [m³/tijdstap]';//Toestroom naar riool [m³/tijdstap]';

	flowTitles[EVAPOTRANSPIRATION] = 'Evapotranspiration[m³/tijdstap]';//'Verdamping [m³/tijdstap]';
	flowTitles[GROUND_TRANSPIRATION] = 'Plant transpiration [m³/tijdstap]';//'Plant transpiratie [m³/tijdstap]';
	flowTitles[SURFACE_EVAPORATIONLAND] = 'Evaporation Land [m³/tijdstap]';//'Verdamping Land [m³/tijdstap]';
	flowTitles[SURFACE_EVAPORATIONWATER] = 'Evaporation Water [m³/tijdstap]';// 'Verdamping Water [m³/tijdstap]';


	flowTitles[SEWER_POC] = 'POC Sewer [m³/tijdstap]';//'POCRiool [m³/tijdstap]';

	flowTitles[SEWER_OVERFLOW_OUT] = 'Sewer Overflow [m³/tijdstap]';//'Riooloverstort [m³/tijdstap]';

	flowTitles[INLET_SURFACE] = 'Inlet (surface) [m³/tijdstap]';//'Inlaat bovengronds [m³/tijdstap]';
	flowTitles[INLET_GROUND] = 'Inlet (ground) [m³/tijdstap]';//'Inlaat ondergronds [m³/tijdstap]';
	flowTitles[OUTLET_SURFACE] = 'Outlet (surface) [m³/tijdstap]';//'Uitlaat bovengronds [m³/tijdstap]';
	flowTitles[OUTLET_GROUND] = 'Outlet (ground) [m³/tijdstap]';//'Uitlaat ondergronds [m³/tijdstap]';
	flowTitles[BOTTOM_FLOW_IN] = 'Bottom flow in [m³/tijdstap]';//'Kwel [m³/tijdstap]';
	flowTitles[BOTTOM_FLOW_OUT] = 'Bottom flow out [m³/tijdstap]';//'Uitzijging [m³/tijdstap]';
	flowTitles[CULVERT] = 'Culvert [m³/tijdstap]';//'Duiker [m³/tijdstap]';
	flowTitles[CULVERT_IN] = 'Culvert in [m³/tijdstap]';//'Duiker in waterbeheergebied [m³/tijdstap]';
	flowTitles[CULVERT_OUT] = 'Culvert out [m³/tijdstap]';//'Duiker uit waterbeheergebied [m³/tijdstap]';
	flowTitles[CULVERT_INNER] = 'Culvert within [m³/tijdstap]';//'Duiker binnen waterbeheergebied [m³/tijdstap]';
	flowTitles[PUMP] = 'Pump';//'Pomp';
	flowTitles[PUMP_IN] = 'Pump in [m³/tijdstap]';//'Pomp in waterbeheergebied [m³/tijdstap]';
	flowTitles[PUMP_OUT] = 'Pump out [m³/tijdstap]';//'Pomp uit waterbeheergebied [m³/tijdstap]';
	flowTitles[PUMP_INNER] = 'Pump within [m³/tijdstap]';//'Pomp binnen waterbeheergebied [m³/tijdstap]';
	flowTitles[WEIR] = 'Weir';//'Stuw';
	flowTitles[WEIR_IN] = 'Weir in [m³/tijdstap]';//'Stuw in [m³/tijdstap]';
	flowTitles[WEIR_OUT] = 'Weir out [m³/tijdstap]';//'Stuw uit [m³/tijdstap]';
	flowTitles[WEIR_INNER] = 'Weir within [m³/tijdstap]';//'Stuw binnen waterbeheergebied [m³/tijdstap]';
	flowTitles[MODEL_IN] = 'Water Level Area in [m³/tijdstap]';//'Waterbeheergebied in [m³/tijdstap]';
	flowTitles[MODEL_OUT] = 'Water Level Area out [m³/tijdstap]';//'Waterbeheergebied uit [m³/tijdstap]';

	flowTitles[M3GROUND] = 'Groundwater [m³]';//'Grondwater [m³]';
	flowTitles[M3UNSATURATED] = 'Unsaturated zone [m³]';//'Onverzadigde zone [m³]';
	flowTitles[M3SATURATED] = 'Saturated zone [m³]';//'Verzadigde zone [m³]';
	flowTitles[M3LAND] = 'Land [m³]';//'Land [m³]';
	flowTitles[M3WATER] = 'Surface water [m³]';//'Oppervlaktewater [m³]';
	flowTitles[M3STORAGE] = 'Building storage [m³]';//'Berging voorzieningen [m³]';
	flowTitles[M3TOTAL] = 'Surface [m³]';//'Surface [m³]';
	flowTitles[M3SEWER] = 'Sewer [m³]';//'Riolering [m³]';
	flowTitles[BREACH] = 'Breach';//'Bres';
	flowTitles[BREACH_IN] = 'Breach in [m³/tijdstap]';//'Bres in [m³/tijdstap]';
	flowTitles[BREACH_OUT] = 'Breach out [m³/tijdstap]';//'Bres uit [m³/tijdstap]';

	return flowTitles;
}

function initFlowColors() {
	let flowColors = {};
	// Model In/Out
	flowColors[MODEL_IN] = [44, 160, 44, 0.5];           // Groen
	flowColors[MODEL_OUT] = [214, 39, 40, 0.5];          // Rood

	//Natuurlijlke processen
	flowColors[RAINM3] = [31, 119, 180, 0.5];          // Donkerblauw - Neerslag
	flowColors[RAINM3LAND] = [31, 119, 180, 0.5];          // Donkerblauw - Neerslag
	flowColors[RAINM3WATER] = [31, 119, 180, 0.5];
	flowColors[RAINM3STORAGE] = [31, 119, 180, 0.5];

	flowColors[LANDSEWER] = [31, 119, 180, 0.5];



	flowColors[EVAPOTRANSPIRATION] = [31, 119, 180, 0.5];
	flowColors[GROUND_TRANSPIRATION] = [31, 119, 180, 0.5];
	flowColors[SURFACE_EVAPORATIONLAND] = [31, 119, 180, 0.5];
	flowColors[SURFACE_EVAPORATIONWATER] = [31, 119, 180, 0.5];


	flowColors[BOTTOM_FLOW_IN] = [31, 119, 180, 0.5];
	flowColors[BOTTOM_FLOW_OUT] = [31, 119, 180, 0.5];

	// Berging - Lichtblauw
	flowColors[M3LAND] = [196, 196, 220, 0.5];         // Berging land
	flowColors[M3WATER] = [196, 196, 220, 0.5];        // Oppervlaktewater
	flowColors[M3GROUND] = [196, 196, 220, 0.5];       // Bodem
	flowColors[M3STORAGE] = [196, 196, 220, 0.5];      // Gebouwen
	flowColors[M3UNSATURATED] = [196, 196, 220, 0.5];      // Onverzadidge zone
	flowColors[M3SATURATED] = [196, 196, 220, 0.5];      // Verzadidge zone
	flowColors[M3TOTAL] = [196, 196, 220, 0.5];        // Totale berging (optioneel)

	// Kunstwerken - Oranje
	flowColors[INLET_SURFACE] = [255, 127, 14, 0.5];
	flowColors[INLET_GROUND] = [255, 127, 14, 0.5];
	flowColors[OUTLET_SURFACE] = [255, 127, 14, 0.5];
	flowColors[OUTLET_GROUND] = [255, 127, 14, 0.5];
	flowColors[PUMP] = [255, 127, 14, 0.5];
	flowColors[PUMP_IN] = [255, 127, 14, 0.5];
	flowColors[PUMP_OUT] = [255, 127, 14, 0.5];
	flowColors[PUMP_INNER] = [255, 127, 14, 0.5];
	flowColors[SEWER_OVERFLOW_OUT] = [255, 127, 14, 0.5]; // Overstort
	flowColors[SEWER_POC] = [255, 127, 14, 0.5];           // POC
	flowColors[CULVERT] = [255, 127, 14, 0.5];
	flowColors[CULVERT_IN] = [255, 127, 14, 0.5];
	flowColors[CULVERT_OUT] = [255, 127, 14, 0.5];
	flowColors[CULVERT_INNER] = [255, 127, 14, 0.5];
	flowColors[WEIR] = [255, 127, 14, 0.5];
	flowColors[WEIR_IN] = [255, 127, 14, 0.5];
	flowColors[WEIR_OUT] = [255, 127, 14, 0.5];
	flowColors[WEIR_INNER] = [255, 127, 14, 0.5];
	flowColors[BREACH] = [255, 127, 14, 0.5];
	flowColors[BREACH_IN] = [255, 127, 14, 0.5];
	flowColors[BREACH_OUT] = [255, 127, 14, 0.5];

	return flowColors;
}

function initNodeColors() {
	let nodeColors = {};

	nodeColors[MODEL_IN] = "#2ca02c";
	nodeColors[MODEL_OUT] = "#d62728";
	nodeColors[M3LAND] = "#6699cc";
	nodeColors[M3WATER] = "#6699cc";
	nodeColors[M3GROUND] = "#6699cc";
	nodeColors[M3STORAGE] = "#6699cc";
	nodeColors[M3SEWER] = "#6699cc";
	nodeColors[M3UNSATURATED] = "#6699cc";
	nodeColors[M3SATURATED] = "#6699cc";
	nodeColors[RAINM3] = "#1f77b4";
	nodeColors[RAINM3LAND] = "#c5b0d5";
	nodeColors[RAINM3WATER] = "#8c564b";
	nodeColors[RAINM3STORAGE] = "#c49c94";
	nodeColors[GROUND_TRANSPIRATION] = "#1f77b4";
	nodeColors[EVAPOTRANSPIRATION] = "#1f77b4";
	nodeColors[SURFACE_EVAPORATIONLAND] = "#1f77b4";
	nodeColors[SURFACE_EVAPORATIONWATER] = "#1f77b4";
	nodeColors[BOTTOM_FLOW_IN] = "#1f77b4";
	nodeColors[BOTTOM_FLOW_OUT] = "#1f77b4";
	nodeColors[LANDSEWER] = "#17becf";
	nodeColors[SEWER_POC] = "#ff7f0e";
	nodeColors[SEWER_OVERFLOW_OUT] = "#ff7f0e";
	nodeColors[CULVERT] = "#ff7f0e";
	nodeColors[CULVERT_IN] = "#ff7f0e";
	nodeColors[CULVERT_OUT] = "#ff7f0e";
	nodeColors[CULVERT_INNER] = "#ff7f0e";
	nodeColors[INLET_SURFACE] = "#ff7f0e";
	nodeColors[OUTLET_SURFACE] = "#ff7f0e";
	nodeColors[INLET_GROUND] = "#ff7f0e";
	nodeColors[OUTLET_GROUND] = "#ff7f0e";
	nodeColors[PUMP] = "#ff7f0e";
	nodeColors[PUMP_IN] = "#ff7f0e";
	nodeColors[PUMP_OUT] = "#ff7f0e";
	nodeColors[PUMP_INNER] = "#ff7f0e";
	nodeColors[WEIR] = "#ff7f0e";
	nodeColors[WEIR_IN] = "#ff7f0e";
	nodeColors[WEIR_OUT] = "#ff7f0e";
	nodeColors[WEIR_INNER] = "#ff7f0e";
	nodeColors[BREACH] = "#ff7f0e";
	nodeColors[BREACH_IN] = "#ff7f0e";
	nodeColors[BREACH_OUT] = "#ff7f0e";

	return nodeColors;
}

const AREA_ID = "AreaID";
queries.addQuery(AREA_ID, '$ID');
const areaID = queries.getData(AREA_ID, false);


const flowTitles = initFlowTitles();
const flowColors = initFlowColors();

const flowProperties = [TIMEFRAMES, TIMEFRAMETIMES, MODEL_IN, MODEL_OUT, RAINM3, RAINM3LAND, RAINM3WATER, RAINM3STORAGE, GROUND_TRANSPIRATION, EVAPOTRANSPIRATION, SURFACE_EVAPORATIONLAND, SURFACE_EVAPORATIONWATER, BOTTOM_FLOW_IN, BOTTOM_FLOW_OUT, LANDSEWER, SEWER_POC, SEWER_OVERFLOW_OUT, CULVERT_IN, CULVERT_OUT, CULVERT_INNER, INLET_SURFACE, OUTLET_SURFACE, INLET_GROUND, OUTLET_GROUND, PUMP_IN, PUMP_OUT, PUMP_INNER, WEIR_IN, WEIR_OUT, WEIR_INNER, BREACH_IN, BREACH_OUT];
const flowData = createTimeframeData(timeframes, areaID, flowProperties);

const CULVERT_AREA_FROM = "culvertAreaFrom";
const CULVERT_AREA_TO = "culvertAreaTo";
const PUMP_AREA_FROM = "pumpAreaFrom";
const PUMP_AREA_TO = "pumpAreaTo";
const INLET_AREA_FROM = "inletAreaFrom";
const INLET_AREA_TO = "inletAreaTo";
const WEIR_AREA_FROM = "weirAreaFrom";
const WEIR_AREA_TO = "weirAreaTo";
const BREACH_AREA_FROM = "breachAreaFrom";
const BREACH_AREA_TO = "breachAreaTo";
const INLET_UNDERGROUND = "inletUnderground";
const INLET_IS_UNDERGROUND = "inletIsUnderground";
const INLET_IS_SURFACE = "inletIsSurface";

queries.addQuery(CULVERT_AREA_FROM,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(CULVERT_AREA_TO,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_CULVERT_DIAMETER_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_1');
queries.addQuery(PUMP_AREA_FROM,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_PUMP_Q_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(PUMP_AREA_TO,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_PUMP_Q_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_1');
queries.addQuery(INLET_AREA_FROM,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_INLET_Q_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(INLET_AREA_TO,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_INLET_Q_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_1');
queries.addQuery(INLET_UNDERGROUND,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_INLET_Q_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_UNDERGROUND_AND_INDEX_IS_0');
queries.addQuery(WEIR_AREA_FROM,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(WEIR_AREA_TO,
	'$SELECT_ATTRIBUTE_WHERE_BUILDING_IS_XK_WEIR_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_1');
queries.addQuery(BREACH_AREA_FROM,
	'$SELECT_ATTRIBUTE_WHERE_AREA_IS_XK_BREACH_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_0');
queries.addQuery(BREACH_AREA_TO,
	'$SELECT_ATTRIBUTE_WHERE_AREA_IS_XK_BREACH_HEIGHT_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_KEY_IS_OBJECT_WATER_AREA_OUTPUT_AND_INDEX_IS_1');

for (property of
	[CULVERT_AREA_FROM, CULVERT_AREA_TO, PUMP_AREA_FROM, PUMP_AREA_TO, INLET_AREA_FROM, INLET_AREA_TO,
		WEIR_AREA_FROM, WEIR_AREA_TO, BREACH_AREA_FROM, BREACH_AREA_TO, INLET_UNDERGROUND]) {
	flowData[property] = queries.getData(property);
}
flowData[INLET_IS_SURFACE] = flowData[INLET_UNDERGROUND].map((value, _index) => value <= 0);
flowData[INLET_IS_UNDERGROUND] = flowData[INLET_UNDERGROUND].map((value, _index) => value > 0);

flowData[TIMEFRAMES] = data[TIMEFRAMES];
flowData[TIMEFRAMETIMES] = data[TIMEFRAMETIMES];

queries.addQuery(RAINM3,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_RAIN');
queries.addQuery(RAINM3STORAGE,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_BUILDING_LAST_STORAGE');
queries.addQuery(LANDSEWER,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_SEWER_LAST_VALUE');
queries.addQuery(EVAPOTRANSPIRATION,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_EVAPOTRANSPIRATION');
queries.addQuery(GROUND_TRANSPIRATION,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_GROUND_TRANSPIRATION');
queries.addQuery(BOTTOM_FLOW,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID_AND_RESULTTYPE_IS_GROUND_BOTTOM_FLOW');


queries.addQuery(RAINM3LAND,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_RAIN_LAND_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID');
queries.addQuery(RAINM3WATER,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_RAIN_WATER_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID');
queries.addQuery(SURFACE_EVAPORATIONLAND,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_EVAPORATIONLAND_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID');
queries.addQuery(SURFACE_EVAPORATIONWATER,
	'$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_HSO_EVAPORATIONWATER_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID');

for (property of [RAINM3, RAINM3LAND, RAINM3WATER, RAINM3STORAGE, LANDSEWER, EVAPOTRANSPIRATION, SURFACE_EVAPORATIONLAND, SURFACE_EVAPORATIONWATER, GROUND_TRANSPIRATION]) {
	flowData[property] = queries.getData(property).map(stepwise);
}

flowData[BOTTOM_FLOW_IN] = queries.getData(BOTTOM_FLOW).map(countPositive).map(stepwise);
flowData[BOTTOM_FLOW_OUT] = queries.getData(BOTTOM_FLOW).map(countNegative).map(stepwise);


flowData[TIMEFRAMETIMES] = data[TIMEFRAMETIMES];
flowData[M3TOTAL] = data[M3TOTAL];
flowData[M3WATER] = data[M3WATER];
flowData[M3LAND] = data[M3LAND];
flowData[M3STORAGE] = data[M3STORAGE];
flowData[M3GROUND] = data[M3GROUND];
flowData[M3SEWER] = data[M3SEWER];
flowData[M3UNSATURATED] = data[M3UNSATURATED];
flowData[M3SATURATED] = data[M3SATURATED];

flowData[MODEL_IN] = flowData[RAINM3].map((_, i) =>
	flowData[RAINM3][i] +
	flowData[INLET_GROUND][i] +
	flowData[INLET_SURFACE][i] +
	flowData[BOTTOM_FLOW_IN][i]
);

flowData[MODEL_OUT] = flowData[EVAPOTRANSPIRATION].map((_, i) =>
	flowData[EVAPOTRANSPIRATION][i] +
	flowData[OUTLET_GROUND][i] +
	flowData[OUTLET_SURFACE][i] +
	flowData[BOTTOM_FLOW_OUT][i]
);

const BREACH_FLOW = "BREACH_FLOW";
const INLET_FLOW = "INLET_FLOW";
const WEIR_FLOW = "WEIR_FLOW";
const CULVERT_FLOW = "CULVERT_FLOW";
const PUMP_FLOW = "PUMP_FLOW";
const DRAINAGE_FLOW = "DRAINAGE_FLOW";
const SEWER_FLOW = "SEWER_FLOW";
const SERVER_OVERFLOW = "SERVER_OVERFLOW";

queries.addQuery(BREACH_FLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_AREA_IS_XK_BREACH_HEIGHT_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(INLET_FLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XK_INLET_Q_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(WEIR_FLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XK_WEIR_HEIGHT_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(CULVERT_FLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XK_CULVERT_DIAMETER_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(PUMP_FLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XK_PUMP_Q_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(DRAINAGE_FLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XK_DRAINAGE_Q_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(SEWER_FLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_AREA_IS_XK_SEWER_STORAGE_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');
queries.addQuery(SERVER_OVERFLOW,
	'$SELECT_ATTRIBUTE_WHERE_KEY_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XK_SEWER_OVERFLOW_AND_TIMEFRAME_IS_Y_AND_GRID_WITH_ATTRIBUTE_IS_HSO_WATER_OVERLAY');

queries.getData(BREACH_FLOW, false).map((values, timeframe, _array) =>
	addFlowValues(flowData, timeframe, BREACH_IN, BREACH_OUT, BREACH_AREA_FROM, BREACH_AREA_TO, values));

queries.getData(INLET_FLOW, false).map((values, timeframe, _array) =>
	addFlowValues(flowData, timeframe, INLET_SURFACE, OUTLET_SURFACE, INLET_AREA_FROM, INLET_AREA_TO, values, condition = INLET_IS_SURFACE));


queries.getData(INLET_FLOW, false).map((values, timeframe, _array) =>
	addFlowValues(flowData, timeframe, INLET_GROUND, OUTLET_GROUND, INLET_AREA_FROM, INLET_AREA_TO, values, condition = INLET_IS_UNDERGROUND));


queries.getData(WEIR_FLOW, false).map((values, timeframe, _array) =>
	addFlowValuesWithInner(flowData, timeframe, WEIR_IN, WEIR_OUT, WEIR_INNER, WEIR_AREA_FROM, WEIR_AREA_TO, values));

queries.getData(CULVERT_FLOW, false).map((values, timeframe, _array) =>
	addFlowValuesWithInner(flowData, timeframe, CULVERT_IN, CULVERT_OUT, CULVERT_INNER, CULVERT_AREA_FROM, CULVERT_AREA_TO, values));

queries.getData(PUMP_FLOW, false).map((values, timeframe, _array) =>
	addFlowValuesWithInner(flowData, timeframe, PUMP_IN, PUMP_OUT, PUMP_INNER, PUMP_AREA_FROM, PUMP_AREA_TO, values));

//queries.getData(DRAINAGE_FLOW, false).map((values, index, _array) =>
//	addFlowValues(flowData, index, DRAINGE_IN, DRAINAGE_OUT, DRAINAGE_AREA_FROM, DRAINAGE_AREA_TO, values));

//Berging Riool - POC
const sewerPOC = queries.getData(SEWER_FLOW, false);

let sewerPOCSums = [];

for (let areaKey = 0; areaKey < sewerPOC.length; areaKey++) {
	let areaValues = sewerPOC[areaKey];
	for (let timeframeKey = 0; timeframeKey < areaValues.length; timeframeKey++) {
		sewerPOCSums[timeframeKey] = sewerPOCSums[timeframeKey] ?? 0;
		sewerPOCSums[timeframeKey] = sewerPOCSums[timeframeKey] + areaValues[timeframeKey];
	}
}

flowData[SEWER_POC] = sewerPOCSums;

const sewerOverflow = queries.getData(SERVER_OVERFLOW, false);

let sewerOverflowSums = [];

for (let buildingKey = 0; buildingKey < sewerOverflow.length; buildingKey++) {
	let buildingValues = sewerOverflow[buildingKey];
	for (let timeframeKey = 0; timeframeKey < buildingValues.length; timeframeKey++) {
		sewerOverflowSums[timeframeKey] = sewerOverflowSums[timeframeKey] ?? 0;
		sewerOverflowSums[timeframeKey] = sewerOverflowSums[timeframeKey] + buildingValues[timeframeKey];
	}
}

flowData[SEWER_OVERFLOW_OUT] = sewerOverflowSums;

createTable("waterFlowTable", flowData, flowProperties, flowColors, flowTitles);

const sankeyproperties = [TIMEFRAMES, MODEL_IN, MODEL_OUT, M3LAND, M3WATER, M3GROUND, M3SATURATED, M3UNSATURATED, M3STORAGE, M3SEWER, RAINM3, RAINM3LAND, RAINM3WATER, RAINM3STORAGE, GROUND_TRANSPIRATION, EVAPOTRANSPIRATION, SURFACE_EVAPORATIONLAND, SURFACE_EVAPORATIONWATER, BOTTOM_FLOW_IN, BOTTOM_FLOW_OUT, LANDSEWER, SEWER_POC, SEWER_OVERFLOW_OUT, CULVERT, CULVERT_IN, CULVERT_OUT, CULVERT_INNER, INLET_SURFACE, OUTLET_SURFACE, INLET_GROUND, OUTLET_GROUND, PUMP, PUMP_IN, PUMP_OUT, PUMP_INNER, WEIR, WEIR_IN, WEIR_OUT, WEIR_INNER, BREACH, BREACH_IN, BREACH_OUT];

let links = createLinks(sankeyproperties);
for (let i = 0; i < timeframes; i++) {
	//Model in
	addLink(links, i, MODEL_IN, RAINM3, flowData[RAINM3][i]);
	addLink(links, i, MODEL_IN, INLET_GROUND, flowData[INLET_GROUND][i]);
	addLink(links, i, MODEL_IN, INLET_SURFACE, flowData[INLET_SURFACE][i]);
	addLink(links, i, MODEL_IN, BOTTOM_FLOW_IN, flowData[BOTTOM_FLOW_IN][i]);
	addLink(links, i, MODEL_IN, CULVERT, flowData[CULVERT_IN][i]);
	addLink(links, i, MODEL_IN, PUMP, flowData[PUMP_IN][i]);
	addLink(links, i, MODEL_IN, WEIR, flowData[WEIR_IN][i]);
	addLink(links, i, MODEL_IN, BREACH, flowData[BREACH_IN][i]);

	//Neerslag	
	addLink(links, i, RAINM3, M3LAND, flowData[RAINM3LAND][i]);
	addLink(links, i, RAINM3, M3WATER, flowData[RAINM3WATER][i]);
	addLink(links, i, RAINM3, M3STORAGE, flowData[RAINM3STORAGE][i]);

	//Berging Land
	addLink(links, i, M3LAND, M3SEWER, flowData[LANDSEWER][i]);
	addLink(links, i, M3LAND, SURFACE_EVAPORATIONLAND, flowData[SURFACE_EVAPORATIONLAND][i]);
	//addLink(links, i, M3LAND, M3GROUND, flowData[][i]);

	//Berging oppervlaktewater
	//addLink(links, i, M3WATER, M3GROUND, flowData[][i]);
	addLink(links, i, M3WATER, WEIR, flowData[WEIR_OUT][i]);
	addLink(links, i, M3WATER, SURFACE_EVAPORATIONWATER, flowData[SURFACE_EVAPORATIONWATER][i]);
	addLink(links, i, M3WATER, CULVERT, flowData[CULVERT_OUT][i]);
	addLink(links, i, M3WATER, OUTLET_SURFACE, flowData[OUTLET_SURFACE][i]);
	addLink(links, i, M3WATER, PUMP, flowData[PUMP_OUT][i]);
	addLink(links, i, M3WATER, PUMP, flowData[PUMP_INNER][i]);
	addLink(links, i, M3WATER, WEIR, flowData[WEIR_INNER][i]);
	addLink(links, i, M3WATER, CULVERT, flowData[CULVERT_INNER][i]);


	//Berging Bodem
	addLink(links, i, M3GROUND, BOTTOM_FLOW_OUT, flowData[BOTTOM_FLOW_OUT][i]);
	addLink(links, i, M3GROUND, GROUND_TRANSPIRATION, flowData[GROUND_TRANSPIRATION][i]);
	addLink(links, i, M3GROUND, OUTLET_GROUND, flowData[OUTLET_GROUND][i]);

	//Berging Riool
	addLink(links, i, M3SEWER, SEWER_OVERFLOW_OUT, flowData[SEWER_OVERFLOW_OUT][i]);
	addLink(links, i, M3SEWER, SEWER_POC, flowData[SEWER_POC][i]);

	//Inlaat Surface
	addLink(links, i, INLET_SURFACE, M3LAND, flowData[INLET_SURFACE][i]); // Eigenlijk zou hier een uitsplitsing moeten zijn tussen een inlaat op land en een inlaat in het water

	//Inlaat Ground
	addLink(links, i, INLET_GROUND, M3GROUND, flowData[INLET_GROUND][i]);

	//Uitlaat Surface
	addLink(links, i, OUTLET_SURFACE, MODEL_OUT, flowData[OUTLET_SURFACE][i]);

	//Uitlaat Land
	addLink(links, i, OUTLET_GROUND, MODEL_OUT, flowData[OUTLET_GROUND][i]);

	//Kwel 
	addLink(links, i, BOTTOM_FLOW_IN, M3GROUND, flowData[BOTTOM_FLOW_IN][i]);

	//Riool overstort
	addLink(links, i, SEWER_OVERFLOW_OUT, M3LAND, flowData[SEWER_OVERFLOW_OUT][i]);

	//POC
	addLink(links, i, SEWER_POC, MODEL_OUT, flowData[SEWER_POC][i]);

	//Wegzijging
	addLink(links, i, BOTTOM_FLOW_OUT, MODEL_OUT, flowData[BOTTOM_FLOW_OUT][i]);

	//Transpiratie
	addLink(links, i, GROUND_TRANSPIRATION, MODEL_OUT, flowData[GROUND_TRANSPIRATION][i]);

	//Verdamping
	addLink(links, i, SURFACE_EVAPORATIONLAND, MODEL_OUT, flowData[SURFACE_EVAPORATIONLAND][i]);
	addLink(links, i, SURFACE_EVAPORATIONWATER, MODEL_OUT, flowData[SURFACE_EVAPORATIONWATER][i]);

	//Stuw
	addLink(links, i, WEIR, MODEL_OUT, flowData[WEIR_OUT][i]);
	addLink(links, i, WEIR, M3WATER, flowData[WEIR_INNER][i]);

	//Duiker in
	addLink(links, i, CULVERT, M3WATER, flowData[CULVERT_IN][i]);
	addLink(links, i, CULVERT, M3WATER, flowData[CULVERT_INNER][i]);

	//Duiker uit
	addLink(links, i, CULVERT, MODEL_OUT, flowData[CULVERT_OUT][i]);

	//Pomp
	addLink(links, i, PUMP, M3WATER, flowData[PUMP_IN][i]);
	addLink(links, i, PUMP, M3WATER, flowData[PUMP_INNER][i]);

	//Bres
	addLink(links, i, BREACH, M3LAND, flowData[BREACH_IN][i]);
	addLink(links, i, M3LAND, BREACH, flowData[BREACH_OUT][i]);
	addLink(links, i, BREACH, MODEL_OUT, flowData[BREACH_OUT][i]);


}

const nodeColors = initNodeColors();
const sankeyLayout = createSankeyPlotLayout();

const sankeySlider = addTimeframeSlider(document.getElementById("sankeySliderDiv"));

function plotSankey() {
	sankeyPlot(
		"sankeyPlot",         // plotDivName
		links,                // links
		sankeySlider.getValue(),   // timeframe
		sankeyproperties,     // properties
		flowTitles,           // titles
		sankeyLayout,         // layout
		nodeColors           // kleuren als object

	);
}


setupTimeframeSlider(sankeySlider, timeframe, timeframes, plotSankey);

plotSankey();

addDownloadHandler(document.getElementById("balanceCSVButton"), "waterbalance.csv", () => toCSVContent(data, properties, volumeTitles, timeframes));
addDownloadHandler(document.getElementById("flowCSVButton"), "waterflow.csv", () => toCSVContent(flowData, flowProperties, flowTitles, timeframes));


	</script>
