<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>polderapp</title>
	<link rel='stylesheet' >
	<script  charset="utf-8"></script>
	<script src='https://cdn.plot.ly/plotly-3.0.1.min.js' charset="utf-8"></script>
</head>

<body>
	<style>
		@charset "UTF-8";

:root {
	--tygron-white: rgba(245, 245, 245, 1.0);
	--tygron-blue: rgb(10, 173, 207);
}

html, body {
	padding: 0px;
	background-color: white;
}

/* Style the button that is used to open and close the collapsible content */
.collapsible {
	background-color: #eee;
	color: #444;
	cursor: pointer;
	padding: 18px;
	width: 100%;
	border: none;
	text-align: left;
	outline: none;
	font-size: 15px;
}

.active, .collapsible {
	font-weight: bold;
	font-size: 1.5em;
}

/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
.active, .collapsible:hover {
	background-color: cornflowerblue;
	color: white;
}

/* Style the collapsible content. Note: hidden by default */
.content {
	padding: 0 0.25em;
	background-color: white;
	overflow: hidden;
}

.content.direct {
	padding: 0 0em;
}

.content .delayed {
	max-height: 0;
	transition: max-height 0.2s ease-out;
}

.collapsible:after {
	content: '\02795';
	/* Unicode character for "plus" sign (+) */
	font-size: 13px;
	color: white;
	float: right;
	margin-left: 5px;
}

.active:after {
	content: "\2796";
	/* Unicode character for "minus" sign (-) */
}

.datatable thead {
	font-weight: bold;
}

.datatable {
	height: 1px;
	border-collapse: collapse;
	width: 100%;
	table-layout: auto;
	font-family: Arial;
	font-size: 0.9em;
}

.datatable tr {
	/*border-bottom: 1px solid black;*/
	height: 100%;
}

.datatable tr:nth-child(even) {
	background-color: rgb(240, 240, 240)
}

.datatable td {
	height: 100%;
}

.datatable td>div {
	margin: 0.25em;
	padding: 0.25em 0.25em 0.25em 0.25em;
	position: relative;
	border-radius: 0.5em;
}

.timeframe-slider {
  --primaryColor: #0366D6;
  --value-active-color: white;
  --value-background: var(--primaryColor);
  --value-font: 700 12px/1 Arial;
  --progress-color: #EEE;
  --progress-shadow: 2px 2px 4px rgba(0,0,0, .1) inset;
  --fill-color: var(--primaryColor);
  --thumb-size: 16px;
  --track-height: calc(var(--thumb-size)/2);
  --thumb-shadow: 0 0 3px rgba(0,0,0,.2);
  --ticks-thickness: 1px;
  --ticks-height: 5px;
  --ticks-color: silver;
  --step: 1;
  --ticks-count: (var(--max) - var(--min)) / var(--step);
  --maxTicksAllowed: 30;
  --too-many-ticks: Min(1, Max(var(--ticks-count) - var(--maxTicksAllowed), 0));
  --x-step: Max( var(--step), var(--too-many-ticks) * (var(--max) - var(--min)) ); /* manipulate the number of steps if too many ticks exist, so there would only be 2*/
  --tickInterval: 100/((var(--max) - var(--min)) / var(--step)) * var(--tickEvery, 1);
  --tickIntervalPerc: calc((100% - var(--thumb-size))/( (var(--max) - var(--min)) / var(--x-step) ) * var(--tickEvery, 1));
  --completed: calc((var(--value) - var(--min) ) / (var(--max) - var(--min)) * 100);
  
  @mixin thumb{
    appearance: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background: var(--thumb-color, white);
    border: 1px solid silver;
    box-shadow: var(--inner-shadow, 0 0), var(--thumb-shadow);
  }
  
  display: inline-block;
  height: var(--thumb-size);
  margin: calc((var(--thumb-size) - var(--track-height)) * -.25) var(--thumb-size) 0;
  background: linear-gradient(to right, var(--ticks-color) var(--ticks-thickness), transparent 1px) repeat-x;
  background-size: var(--tickIntervalPerc) var(--ticks-height);
  background-position: calc(var(--thumb-size)/2) bottom;
  padding-bottom: var(--ticks-height);
  position: relative;

  &::before, 
  &::after {
    font: 12px Arial;
    content: counter(x);
    position: absolute;
    bottom: -2.5ch;
  }
  
  &::before {
    counter-reset: x var(--min);
    left: 0;
  }
  
  &::after {
    counter-reset: x var(--max);
    right: 0;
  }
  
  &__progress {
    position: absolute;
    left: 0;
    top: calc(50% - var(--ticks-height)/2);
    transform: translateY(-50%);
    width: 100%;
    height: calc(var(--track-height));
    pointer-events: none;
    z-index: -1;
    box-shadow: var(--progress-shadow); 
    border-radius: 20px;
    background: var(--fill-color, white);

    &::before {
      content: '';
      display: block;
      margin-left: auto;
      margin-right: -.5px;
      width: calc(100% - var(--completed) * 1%);
      height: 100%;
      background: var(--progress-color, #EEE);
      box-shadow: inherit;
      border-radius: 0 20px 20px 0;
    }
  }
  
  & > input {
    width: 100%;
    height: var(--thumb-size);
   /* margin: 0 calc(var(--thumb-size)/-2);*/
    margin: 0;
    cursor: -webkit-grab;
    cursor: grab;
    outline: none;
    background: none;
    
    &::-webkit-slider-thumb { 
      @include thumb;
    }
    
    &::-moz-slider-thumb { 
      @include thumb;
    }
    
    &::-ms-thumb { 
      @include thumb;
    }
    
    &:active {
      cursor: grabbing;
      --thumb-color: var(--fill-color);
      --inner-shadow: 0 0 0 calc(var(--thumb-size)/4) inset white;
      + output { transition: 0s; }
    }
    
    &:hover + output {
      background: var(--value-background);
      color: var(--value-active-color);
      transform: translate(var(--x-offset), 0);
      box-shadow: 0 0 0 3px var(--value-background);
    }
  }

  & > output {
    --x-offset: calc(var(--completed) * -1%);
    pointer-events: none;
    position: absolute;
    background: transparent;
    border-radius: 10px;
    padding: 0 4px;
    top: -3ch; /* calc(Max(var(--thumb-size), var(--track-height)) * -1);*/
    left: calc(((var(--value) - var(--min))/(var(--max) - var(--min))) * 100%);
    transform: translate(var(--x-offset), 6px);
    transition: all .12s ease-out, left 0s, top 0s;
  
    &::after {
      content: var(--text-value);
      font: var(--value-font);
    }
  }
}
/*Polderapp override css here*/
.column {
	
	height: 100%;
	max-height: auto;
	overflow-x: scroll;
	border: 1px solid grey;
	border-radius: 20px;
	box-shadow: 2px 2px 10px #c1c1c1;
	font-family: Arial;
	padding:30px;
	margin:10px;
}


.grid {
	display: grid;
	grid-template-columns: 50% auto;
	/*grid-template-rows: 45% auto;*/
	width: 100%;
	height: 100%;
	gap: 25px;
	
}

.flex-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.slider-background{
	margin:1em;
	width:95%;
	height:15px;
}




	</style>
	<div class=".flex-container ">
		<div class="column">
			<div class="timeframe-slider range--ticks slider-background"
				style='--step: 1; --min: 0; --max: 1; --value: 1; --text-value: "1"; --primaryColor: red; --fill-color: unset; --value-background: unset; --value-active-color: unset;'>
				<input id="barSlider" class="timeframe-slider" type="range" min="0" max="1" step="1" value="1"
					oninput="this.parentNode.style.setProperty('--value',this.value); this.parentNode.style.setProperty('--text-value', JSON.stringify(this.value))">
				<output></output>
			</div>
			<div id="balancePlot" />
		</div>
	</div>
	<div class="column">
		<label>Download: </label><button id="balanceCSVButton">CSV</button>
		<table id="waterBalanceTable" class="datatable"></table>
	</div>

	<div class="column">
		<div class="timeframe-slider range--ticks slider-background"
			style='--step: 1; --min: 0; --max: 1; --value: 1; --text-value: "1"; --primaryColor: red; --fill-color: unset; --value-background: unset; --value-active-color: unset;'>
			<input id="sankeySlider" class="timeframe-slider" type="range" min="0" max="1" step="1" value="1"
				oninput="this.parentNode.style.setProperty('--value',this.value); this.parentNode.style.setProperty('--text-value', JSON.stringify(this.value))">
			<output></output>
		</div>
		<div id="sankeyPlot"></div>
	</div>
	<div class="column">
		<label>Download: </label><button id="flowCSVButton">CSV</button>
		<table id="waterFlowTable" class="datatable"></table>
	</div>
	</div>
	<script>
		

class ArrayUtils {

	/** 
	 * 	Rescale a value to desired range. 
	 * 		E.g. Turn fraction into neat percentage: scaleValue(fraction, [0,1], [0,100], true)
	 * 		Non-numeric value input is ignored and returned as-is.
	 * 		originalRange and targetRange must be an array of exactly 2 different numbers
	*/
	static scaleValue(value, originalRange, targetRange, round = false) {
		if (!NumberUtils.isNumeric(value)) {
			return value;
		}
		if ((!this.isRange(originalRange)) || (!this.isRange(targetRange))) {
			throw 'Both the original and target range must be array of 2 different numeric values';
		}
		value = ((value - originalRange[0]) / (originalRange[1] - originalRange[0]));
		value = (value * (targetRange[1] - targetRange[0])) + targetRange[0];

		return round ? Math.round(value) : value;
	}

	/** 
	 *	Array-wrapper for scaleValue
	*/
	static scaleValues(values, originalRange, targetRange, round = false) {
		if (!(Array.isArray(values)|| this.isMap(values)) ) {
			return this.scaleValue(values, originalRange, targetRange, round);
		}

		let arr = this.isMap(values) ? {} : [];
		for (let i in values) {
			arr[i] = (this.scaleValues(values[i], originalRange, targetRange, round));
		}
		return arr;
	}

	/**
	 *	Convenience function wrapping an array's ForEach, to return the array for in-lining'.
	 *	Operates in-place
	 */
	static forEach(array, func) {
		if ( !Array.isArray(array) ) {
			throw 'Not an array to iterate on';
		}
		if ( typeof func !== 'function' ) {
			throw 'Not a function to apply';
		}
		for( let i in array ) {
			let output = func(array[i],i,array);
			if (typeof output !== 'undefined') {
				array[i] = output;
			}	
		}
		return array;
	}
	
	static isRange(value, allowEqual = false) {
		if (!Array.isArray(value) || value.length != 2) {
			return false;
		}
		if ((!NumberUtils.isNumeric(value[0])) || (!NumberUtils.isNumeric(value[1]))) {
			return false;
		}
		return ((value[0] != value[1]) || allowEqual);
	}

	static coerceToArray(value) {
		return (!Array.isArray(value)) ? [value] : value;
	}
	static unArrayIfSingleElement(value, nullIfEmpty = true) {
		if (!Array.isArray(value)) {
			return value;
		}
		if (value.length === 1) {
			return value[0];
		}
		if (value.length === 0) {
			return nullIfEmpty ? null : value;
		}
		return value
	}
	
	static filterByArray(data, filter, func = null) {
		if ( !Array.isArray(data) ) { 
			throw new TypeError('Data must be an array');
		}
		if ( !Array.isArray(filter) ) {
			throw new TypeError('Filter must be an array');
		}
		
		if (typeof func !== 'function') {
			func = (d,f) => {return !!f};
		}
		
		let values = [];
		for ( let i=0 ; i < Math.min(data.length, filter.length) ; i++ ) {
			if (typeof func === 'function') {
				if ( func( data[i], filter[i] ) ) {
					values.push( data[i] );
				}
			}
		}
		return values;
	}
	
	/* Simple check to see if value is mapping, rather than array or primitive. For simplicity, objects are maps */
	static isMap(obj) 	{
		if (!obj) {
			// Not null or undefined
			return false;
		}
		if ( Array.isArray(obj) ) {
			// Not an array
			return false;
		}
		if ( ({}).constructor == Object(obj).constructor ) {
			// Has a generic object constructor
			return true;
		}
		return false;
	}

	static mapFromKeyValueArray(array) {
		if (this.isMatrix(array)) {
			return this.mapFromKeyValueMatrix(array);
		}

		let map = {};
		for(let i = 0 ; i < array.length ; i+=2) {
			map[array[i]] = array[i+1];
		}
		return map;
	}
	
	static mapFromKeyValueMatrix(matrix) {
		if (!this.isMatrix(matrix)) {
			return this.mapFromKeyValueArray(matrix);
		}
		
		let list = [];
		for (let i=0;i<matrix.length;i++) {
			list.push(this.mapFromKeyValueArray(matrix[i]));
		}
		
		return list;
	}
	
	static mergeMaps(concat, ...maps) {
		let newMap = {};
		
		if (maps.length === 0 ) {
			return newMap;
		}
		
		for (let key in maps[0]) {
			newMap[key] = [];
		}
		
		for (let i=0;i<maps.length;i++) {
			for (let key in newMap) {
				if (concat) {
					newMap[key] = newMap[key].concat(maps[i][key] ?? []);
				} else {
					newMap[key] = newMap[key].push(maps[i][key] ?? null);
				}
			}
		}
		return newMap;
	}
	
	static changeMapKeys(map, remapping) {
		let newMap = {};
		for (let oldKey in map) {
			newMap[remapping[oldKey]] = map[oldKey];
		}
		return newMap;
	}
	
	static flipMatrix(matrix) {
		let newMatrix = [];
		let ySize = null;
		
		for (let i = 0; i < matrix.length; i++) {
			
			ySize = ySize ?? matrix[i].length;
			
			if (matrix[i].length != ySize) {
				throw 'Matrix lengths inconsistent, could not flip';
			}
			
			for (let j = 0; j < matrix[i].length; j++) {
				
				newMatrix[j] = newMatrix[j] ?? [];
				newMatrix[j][i] = matrix[i][j];
			}
		}
		
		return newMatrix;
	}

	static clampMatrixSize(matrix, defaultValue, minSizeOuter, maxSizeOuter, minSizeInner, maxSizeInner) {
		
		let newMatrix = [];
		if (!this.isMatrix(matrix)) {
			throw new TypeError('Not a matrix');
		}
		
		for (let i = 0; i < Math.min(matrix.length, maxSizeOuter ?? matrix.length); i++) {
			
			if ((maxSizeInner ?? -1) < 0) {				
				newMatrix[i] = matrix[i];
			
			} else {				
				newMatrix[i] = matrix[i].slice(0, maxSizeInner);	
			}
			
			if (minSizeInner) {				
				newMatrix[i] = newMatrix[i].concat(Array(Math.max(0,minSizeInner - matrix[i].length)).fill(defaultValue));
			}
		}
		
		if (minSizeOuter) {
			
			for (let i = newMatrix.length; i < minSizeOuter; i++) {
				
				newMatrix[i] = new Array(minSizeInner ?? 0).fill(defaultValue);
			}
		}
		return newMatrix;
	}

	static clampMatrixSizeOuter(matrix, defaultValue, minSize, maxSize) {
		
		return this.clampMatrixSize(matrix, defaultValue, minSize, maxSize, null, null);
	}	

	static clampMatrixSizeInner(matrix, defaultValue, minSize, maxSize) {
		
		return this.clampMatrixSize(matrix, defaultValue, null, null, minSize, maxSize);
	}

	static isMatrix(matrix) {
		
		if (!Array.isArray(matrix)) {
			return false;
		}
		
		for (let inner of matrix) {
			if (!Array.isArray(inner)) {
				return false;
			}
		}
		
		return true;
	}

}

function initCollapsibles() {

	let coll = document.getElementsByClassName("collapsible");
	
	for (let i = 0; i < coll.length; i++) {
		
		coll[i].addEventListener("click", function() {

			this.classList.toggle("active");
			let content = this.nextElementSibling;
			let style = content.style;

			if (content.classList.contains("delayed")) {
				
				if (style.maxHeight) {
					style.maxHeight = null;
				} else {
					style.maxHeight = content.scrollHeight + "px";
				}
			
			} else {
				style.display = style.display === "block" ? "none" : "block";
			}


		});
	}
}

function openCollapsibles() {
	
	let  coll = document.getElementsByClassName("collapsible");
	for (i = 0; i < coll.length; i++) {
		
		const collapsible = coll[i];
		setTimeout(function() {
			collapsible.click();
		}, i * 100);
	}
}
function connector(token, baseUrl, basePath,) {
	
	return {
		token : token ?? null,
		basePath : basePath ?? '/api/session/',
		baseUrl : baseUrl ?? null,
		protocol: 'https',
		
		start(funcToRun) {
			return (typeof funcToRun === 'function') ? Promise.resolve(funcToRun()) : Promise.resolve(funcToRun ?? null);
		},
		
		get(url, queryParams, preparationFunction) {
			let self = this;
			return function(data) {
				return self._call( 'GET', url, queryParams, null, preparationFunction )();
			}
		},
		post(url, queryParams, params, preparationFunction) {
			let self = this;
			return function(data) {
				return self._call( 'POST', url, queryParams, params, preparationFunction )();
			}
		},
		
		recalculate( xqueries ) {
			let self = this;
			return function(data) {
				return self.post('/api/session/event/editorindicator/reset_indicators/',null,[!!xqueries])(data);
			}
		},

		consoleLog: function(message) {
			return function(data) {
				if (message) {
					console.log(message);
				}
				console.log(data);
				return data;
			}
		},
		
		_prepareQueryString: function(queryParams, url) {
			queryParams = queryParams ?? {};
			let queryString = new URLSearchParams(queryParams).toString();
			if ( queryString.length > 0 ) {
				if ( url.indexOf('?')===-1 ) {
					queryString = '?'+ queryString;
				} else {
					queryString = '&'+ queryString;
				}
			}
			return queryString;
		},
		
		_prepareQueryParams: function(queryParams) {
			queryParams = queryParams ?? {};
			if ( !(typeof queryParams === 'object') ) {
				queryParams = {};
			}
			return queryParams;
		},
		
		_prepareParams: function(params) {
			params = params ?? [];
			if (!Array.isArray(params)) {
				params = [params];
			}
			return params;
		},
		
		_call: function (method, url, queryParams, params, preparationFunction) {
			let self = this;
			return function(data) {
				params = method.toUpperCase() == 'GET' ? null : self._prepareParams(params);
				queryParams = self._prepareQueryParams(queryParams);
				queryParams['token'] = queryParams['token'] ?? self.token;
				queryParams['f'] = queryParams['f'] ?? 'JSON';
				
				if (typeof preparationFunction == 'function') {
					url = preparationFunction(data, url, queryParams, params) ?? url;
				}
				
				let queryString = self._prepareQueryString(queryParams, url);
				if ( self.basePath && !(url.indexOf('/')==0) ) {
					url = self.basePath + url;
				}
				if (self.baseUrl) {
					url = self.protocol + self.baseUrl + url;
				}
				url = url + queryString;
				
				let promise = Promise.resolve(
					$.ajax({
						url: url,
						method: method.toUpperCase(),
						contentType: 'application/json',
						dataType: 'json',
						data: JSON.stringify(params),
					})
				);
				return promise;
			};
		},

		//To use a single argument which is an array itself, wrap the arguments in an array.
		chain: function(func, args) {
			if ( typeof args === 'undefined' ) {
				return function(data) {
					return func(data);
				}
			}
			if ( Array.isArray(args) ) {
				return function(data) {
					return func.apply(this, args.slice().unshift(data));
				}
			}
			return function(data) {
				return func.apply(this, [data, args]);
			}
		},
	};
}

/**
 * @param {Array.<string>} properties Array of Property names to set into data
 * @returns {Object} Data Object containing the properties.
 */
function createLinks(properties) {
	
	return { properties: properties };
}

/**
 * @param {Object} data object with String properties, initialized using createLinks method 
 * @param {int} timeframe timeframe index at which the link should be 
 * @return {Object} containing a source, target and value array properties.
 */
function getLink(data, timeframe) {
	
	if (!Array.isArray(data.timeframeLinks)) {
		data.timeframeLinks = [];
	}
	
	while (data.timeframeLinks.length - 1 < timeframe) {
		data.timeframeLinks.push({
			source: [],
			target: [],
			value: [],
		});
	}
	
	return data.timeframeLinks[timeframe];
}

/**
 * @param {Object} data object with String properties, initialized using createLinks method 
 * @param {int} timeframe timeframe index at which the link should be set
 * @param {String} from the property from which an ammount is removed.
 * @param {String} to the property to which an amount is added.
 * @param {Number} amount that is moved between the two properties
 */
function addLink(data, timeframe, from, to, amount) {
	
	let link = getLink(data, timeframe)
	if (!Array.isArray(link.source)) {
		link.source = [];
	}
	if (!Array.isArray(link.target)) {
		link.target = [];
	}
	if (!Array.isArray(link.value)) {
		link.value = [];
	}
	
	link.source.push(data.properties.indexOf(from));
	link.target.push(data.properties.indexOf(to));
	link.value.push(amount);
}


function createTimeframeData(timeframes, itemID, properties) {
	
	let data = {
		itemID: itemID,
		timeframes: timeframes
	};
	
	for (let i = 0; i < properties.length; i++) {
		data[properties[i]] = [];
		for (let j = 0; j < timeframes; j++) {
			data[properties[i]].push(0);
		}
	}
	
	return data;
}

/**
 * @param {*} data Data object
 * @param {*} property Property name to set into data
 * @param {*} values Value array to set under property name into data
 * @param {{}} [args={}] Additional args object, supports .relative and .negative with boolean value
 */
function setTimeframeValues(data, property, values, args = {}) {

	for (let i = 0; i < data[property].length && i < values.length; i++) {
		data[property][i] = values[i];
	}

	if (args.relative) {

		for (let i = 0; i < data[property].length; i++) {
			let previous = i == 0 ? 0 : data[property][i - 1];
			data[property][i] -= previous;
		}
	}
	
	if (args.negative !== undefined) {
		
		if (args.negative) {
			for (let i = 0; i < data[property].length; i++) {
				data[property][i] = Math.abs(Math.min(0, data[property][i]));
			}
		
		} else {
			for (let i = 0; i < data[property].length; i++) {
				data[property][i] = Math.max(0, data[property][i]);
			}
		}
	}
}
/**
 * Unused function, soon te be removed!!!
 */
function setTimeframeValue(data, property, value) {

	for (let i = 0; i < data.dataframes.length; i++) {
		
		data[property][i] = value;
	}
}

function addFlowValues(data, timeframe, propertyFrom, propertyTo, areaIDFrom, areaIDTo, values, condition = undefined) {
	addFlowValuesWithInner(data, timeframe, propertyFrom, propertyTo, undefined, areaIDFrom, areaIDTo, values, condition);
}

function addFlowValuesWithInner(data, timeframe, propertyFrom, propertyTo, propertyInner, areaIDFrom, areaIDTo, values, condition = undefined) {
	
	if (data[propertyFrom][timeframe] == undefined) {
		data[propertyFrom][timeframe] = 0;
	}
	
	if (data[propertyTo][timeframe] == undefined) {
		data[propertyTo][timeframe] = 0;
	}
	
	if (propertyInner != undefined) {
		if (data[propertyInner][timeframe] == undefined) {
			data[propertyInner][timeframe] = 0;
		}
	}
	
	for (let i = 0; i < values.length && i < areaIDFrom.length && i < areaIDTo.length; i++) {
		
		if ((areaIDTo[i] == data.itemID) && (areaIDFrom[i] == data.itemID) && (condition == undefined || condition[i])) {
			
			if (propertyInner != undefined) {
				
				if (values[i] > 0) {
					data[propertyInner][timeframe] += values[i];
				
				} else {
					data[propertyInner][timeframe] -= values[i];
				}
			}
		
		} else if (areaIDTo[i] == data.itemID && (condition == undefined || condition[i])) {
			
			if (values[i] > 0) {
				data[propertyFrom][timeframe] += values[i];
			
			} else {
				data[propertyTo][timeframe] -= values[i];
			}
		
		} else if (areaIDFrom[i] == data.itemID && (condition == undefined || condition[i])) {
			
			if (values[i] > 0) {
				data[propertyTo][timeframe] += values[i];
			
			} else {
				data[propertyFrom][timeframe] -= values[i];
			}
		}
	}
}

function addValuesForTimeframeAndID(data, timeframe, property, idValues, values) {

	if (idValues[i] == data.itemID) {
		if (data[property][timeframe] == undefined) {
			data[property][timeframe] = 0;
		}
		data[property][timeframe] += values[i];
	}

}
function ensureDomElement(domElementId) {
	
	let domElement = domElementId;
	if (!(domElement instanceof HTMLElement)) {
		domElement = document.getElementById(domElementId);
	}
	
	if (!(domElement instanceof HTMLElement)) {
		throw 'No element found matching ' + domElementId;
	}
	
	return domElement;
}

function attachHandler(parentElement, eventType, selector, handler, referenceClass) {
	
	let checkHandler = function(event) {
		event = event || window.event;
		event.target = event.target || event.srcElement;

		let foundElement = selector ? event.target.closest(selector) : parentElement;
		if (foundElement) {
			handler.call(foundElement, event);
		}
	};

	if (parentElement.addEventListener) {
		parentElement.addEventListener(eventType, checkHandler, false);
	}
	
	if (referenceClass) {
		parentElement.classList.add(referenceClass);
	}
}

function popupPanel(parent, panelID, webPath) {

	let popupPanel = document.createElement('div');
	popupPanel.classList.add('popup');

	let panelCloser = document.createElement('div');
	panelCloser.classList.add('closer');
	attachHandler(panelCloser, 'click', null, function() { clearPopupPanel(parent); });

	let panelFrame = document.createElement('iframe');
	panelFrame.classList.add('popupFrame');

	popupPanel.appendChild(panelCloser);
	popupPanel.appendChild(panelFrame);

	webPath = webPath ?? '/web/panel.html';
	let queryString = 'token=$TOKEN&id=' + panelID;
	let webTarget = webPath + (webPath.indexOf('?') < 0 ? '?' : '&') + queryString;
	panelFrame.src = webTarget;

	clearPopupPanel(parent);
	parent.appendChild(popupPanel);
}

function clearPopupPanel(element) {
	let popups = element.getElementsByClassName('popup');
	for (let i = 0; i < popups.length; i++) {
		popups[i].remove();
	}
	return element;
}

function addDownloadHandler(element, fileName, contentFunction) {
	
	element.addEventListener('click', () => {
		
		let content = contentFunction();
		let blob = new Blob([content], { type: 'text/plain' });

		// temp link 
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		link.download = fileName;
		link.click();

		// cleanup
		URL.revokeObjectURL(link.href);
	});
}

function toCSVContent(data, properties, titles, timeframes) {
	
	let csvContent = "data:text/csv;charset=utf-8,";

	for (let i = 0; i < properties.length; i++) {
		csvContent += titles[properties[i]];
		csvContent += i < properties.length - 1 ? "," : "\r\n";
	}
	
	for (let t = 0; t < timeframes; t++) {
		for (let i = 0; i < properties.length; i++) {
			csvContent += data[properties[i]][t];
			csvContent += i < properties.length - 1 ? "," : "\r\n";
		}
	}

	return csvContent;

}



/**
 * Listing Panel
 * 
 * To display a matrix of information with flexible rendering rules.
 * headers/content/footers : 
 * 		A matrix of values ( 0...n rows/arrays with 0...n values ) to display
 * headersTypes/contentTypes/footerTypes : 
 * 		A matching matrix of rendering types. Either predefined of functions. Either one array for all rows, or a matrix. Missing rows in a matrix use defaultTypes instead
 * defaultHeadersTypes/defaultContentTypes/defaultFootersTypes : 
 * 		A single renderer definition (or array of multiple matching one row) to render with if no list of renderers is provided
 * tableMode : 
 * 		Whether to render as an HTML table. If not, will use divs instead, per cell, per row, and one for the full container 
 * flipXY : 
 * 		If true, the rows in the data will be layed out as columns, and vice versa.
 */

class ListingPanelController {
	
	constructor(domTarget, args = {}) {
		this.args = Object.assign( {
				'content' : [],
				'contentTypes' : [],
				'defaultContentTypes' : 'label',
				
				'headers': [],
				'headersTypes' : [],
				'defaultHeaderTypes' : 'label',
				
				'footers':[],
				'footersTypes': [],
				'defaultFootersTypes': 'label',
				
				'tableMode': true,
				'flipXY' : false,
			}, args );
		
		this.parent = null;
		this.domElement = null;
		
		try {
			this.parent = ensureDomElement(domTarget);
		} catch( err ) {
		}
	}

	addContent(content, renderTypes = null) {
		this.args['content'].push(content);
		if (renderTypes) {
			let index = this.args['content'].length -1;
			this.args['contentTypes'][index] = renderTypes;
		}
	}
	addHeader(content, renderTypes = null) {
		this.args['headers'].push(content);
		if (renderTypes) {
			let index = this.args['content'].length -1;
			this.args['footersTypes'][index] = renderTypes;
		}
	}
	addFooter(content, renderTypes = null) {
		this.args['footers'].push(content);
		if (renderTypes) {
			let index = this.args['content'].length -1;
			this.args['headersTypes'][index] = renderTypes;
		}
	}

	clearContent() {
		this.args['content'] = [];
		this.args['contentTypes'] = [];
	}
	clearHeader() {
		this.args['headers'] = [];
		this.args['footersTypes'] = [];
	}
	clearFooter() {
		this.args['footers'] = [];
		this.args['headersTypes'] = [];
	}
	
	setDefaultContentRenderTypes(renderTypes) {
			this.args['defaultContentTypes'] = renderTypes;
	}
	setDefaultHeaderRenderTypes(renderTypes) {
			this.args['defaultHeadersTypes'] = renderTypes;
	}
	setDefaultFootersRenderTypes(renderTypes) {
			this.args['defaultFootersTypes'] = renderTypes;
	}
	
	/* Based on the configuration and content, create the actual dom elements. */
	render( rerender = true ) {
		if (this.domElement && ! rerender) {
			return this.domElement;
		}
		
		let renderRules = this._createRenderRules(this.args)
		if (this.args['flipXY']) {
			renderRules = ArrayUtils.flipMatrix(renderRules);
		}
		let domElement = this._createDomElement(renderRules, this.args['tableMode']);
		
		if (this.parent) {
			if (this.domElement) {
				this.parent.removeChild(this.domElement);
			}
			this.parent.appendChild(domElement);
		}
		
		this.domElement = domElement;
	}
	
	getValues(section='content') {
		let selector = 'entry'+  (section ? ' '+section : '');
		let entries = this.domElement.getElementsByClassName(selector);
		
		let values = [];
		for (let entry of entries) {
			let entryValues = [];
			let inputs = entry.getElementsByClassName('input');
			for (let input of inputs) {
				entryValues.push(this._getValueFromInput(input));
			}
			values.push(entryValues);
		}
		return values;
	}
	
	getRenderer(type, args) {
		type = type ?? 'label';
		if (typeof type === 'function') {
			return type;
		}
		
		let renderer = null;
		try {
			renderer = ListingPanelController.getRenderer(type, args);
		} catch (err) {
			console.error('Failed to get renderer type '+type+', reason: '+err);
			renderer = ListingPanelController.getRenderer('label');
		}
		return renderer;
	}
	
	
	static DEFAULT_CLASS = 'listingPanel';
	
	
	/* Turn the content and provided render types into prepared render rules for each individual cell of the listing */
	_createRenderRules( args = {} ) {
		
		let renderRules = [];
		for ( let i=0 ; i<args['headers'].length ; i++ ) {
			let types = this._getRenderTypesFromMatrix( args['headersTypes'], i, args['defaultHeaderTypes']);
			let prepared = this._createCellRenderRules(args['headers'][i], types, {'special':'header'});
			if (prepared) {
				renderRules.push(prepared);
			}
		}
		for ( let i=0 ; i<args['content'].length ; i++ ) {
			let types = this._getRenderTypesFromMatrix( args['contentTypes'], i, args['defaultContentTypes']);
			let prepared = this._createCellRenderRules(args['content'][i], types, {'special':'content'});
			if (prepared) {
				renderRules.push(prepared);
			}
		}
		for ( let i=0 ; i<args['footers'].length ; i++ ) {
			let types = this._getRenderTypesFromMatrix( args['footersTypes'], i, args['defaultFootersTypes']);
			let prepared = this._createCellRenderRules(args['footers'][i], types, {'special':'footer'});
			if (prepared) {
				renderRules.push(prepared);
			}
		}
		return renderRules;
	}
	
	/* From a matrix of renderttpes, get the appropriate row if possible. Otherwise, use the default Types. */
	_getRenderTypesFromMatrix(matrix, index, defaultTypes = []) {
		if ( Array.isArray(matrix) ) {
			if ( matrix.length == 0 ) {
				return defaultTypes;
			}
			if ( !ArrayUtils.isMatrix(matrix) ) {
				return matrix;
			}
			return matrix[index] ?? defaultTypes;
		}
		return matrix ?? defaultTypes;
	}
	
	/* Create the render rule for an array of individual cells. */
	_createCellRenderRules(contents = null, renderers = [], defaultRules = {}) {
		defaultRules = Object.assign( {
				'content' 	: null, // Default data, overwritten by the actual data
				'rendering' : null, // Default type to use if "types" does not extend as far as datas
				'special' 	: null, // Whether the rules are for headers, footers, or other special contents
			}, defaultRules );
		if ( contents===null ) {
			return [];
		}
		if ( !Array.isArray(contents) ) {
			contents = [contents];
		}
		if ( !Array.isArray(renderers) ) {
			renderers = Array(contents.length).fill(renderers);
		}
		let cellRenderRules = [];
		for (let i=0;i<contents.length;i++) {
			let renderType = renderers[i];
			let renderOptions = null;
			if (renderType && renderType['type']) {
				renderOptions = renderType ?? null;
				renderType = renderType['type'];
			}
			cellRenderRules.push( Object.assign( {}, defaultRules, {
				'content'	: contents[i],
				'rendering'	: renderType ?? defaultRules['rendering'],
				'options'	: renderOptions,
			} ) );
		}
		return cellRenderRules;
	}
	
	_createDomElement(renderRules, tableMode) {
		
		let domElement;
		let domInnerElement;
		
		if (tableMode) {
			domElement = document.createElement('table');
			domInnerElement = document.createElement('tbody');
			domElement.appendChild(domInnerElement);
		} else {
			domElement = document.createElement('div');
			domInnerElement = domElement;
		}
		
		for ( let i = 0 ; i < renderRules.length ; i++ ) {
			let rowElement = this._createDomElementsRow(renderRules[i], tableMode);
			domInnerElement.appendChild(rowElement);
		}
		domElement.classList.add(ListingPanelController.DEFAULT_CLASS);
		
		return domElement;	
	}
	
	/* Generate */
	_createDomElementsRow(rowRenderRules, tablemode) {
		
		let rowElementType = tablemode ? 'tr' : 'div';
		let rowElement = document.createElement(rowElementType);
		rowElement.classList.add('entry');
		
		let specialRow = null;
		
		for ( let i = 0 ; i < rowRenderRules.length ; i++ ) {
			let cellRule = rowRenderRules[i];
			let contentRenderer = this.getRenderer(cellRule['rendering'], cellRule['options']);
			
			let cellElement = contentRenderer(cellRule['content']);
			if (cellRule['special']) {
				cellElement.classList.add(cellRule['special']);
			}
			
			if (tablemode) {
				let wrappingCell = null;
				if (cellRule['special'] === 'header') {
					wrappingCell = document.createElement('th');
				} else {
					wrappingCell = document.createElement('td');
				}
				wrappingCell.appendChild(cellElement);
				cellElement = wrappingCell;
			}
			
			rowElement.appendChild(cellElement);
			
			specialRow = specialRow ?? cellRule['special'];
			if (specialRow !== cellRule['special']) {
				specialRow = false;	
			}
		}
		
		if (specialRow) {
			rowElement.classList.add(specialRow);
		}
		
		return rowElement;
	}
	
	_getValueFromInput(input) {
		if (typeof input.getValue === 'function') {
			return input.getValue();
		}
		let selecteds = input.getElementsByClassName('selected');
		if (selecteds.length>0) {
			return selecteds[0].value;
		}
	}
	
	//Cache to prevent recreating renderers when many values are displayed the same
	static cachedRenderers = {};
	static getRenderer(type, args) {
		if ( typeof type === 'function') {
			return type;
		}
		
		let cacheKey = JSON.stringify([type,args]);
		let renderer = this.cachedRenderers[cacheKey] ?? null;
		if ( renderer ) {
			return renderer;
		}
	
		switch(type) {
			case 'label':
				renderer = this._getRendererLabel(args);
				break;
			case 'buttons':
				renderer = this._getRendererButtons(args);
				break;
			default:
				throw 'Could not find renderer type '+type;
		}
		
		if (renderer === false) {
			throw 'Rendering type '+type+' requires arguments. Use getRenderer(type, args) to prepare this renderer instance.';
		}
		
		this.cachedRenderers[cacheKey] = renderer;
		return renderer;
	}

	static _applyGenericRendererOptions(element, options) {
		
		for (let key in options) {
			let value = options[key];
			if (key === 'style') {
				for (let subKey in value ) element.style[subKey] = value[subKey];
			}
			if (key === 'class') {
				for (let subKey in value ) element.classList.add( value[subKey] );
			}
		}
		return element;
	}
	
	static _getRendererLabel(options) {
		let opt = options;
		return function(content) {
			let element = document.createElement('div');
			element.classList.add('label');
			let labelElement = document.createElement('span');
			labelElement.innerHTML = content;
			element.appendChild(labelElement);
			
			ListingPanelController._applyGenericRendererOptions(element, opt);
			
			return element;
		}
	}
	
	static _getRendererButtons(options) {
		let opt = options;
		if ( !opt || !opt['inputs'] ) {
		throw 'Options required for buttons renderer';
		}
		
		if ( !Array.isArray(opt['inputs'])) {
			throw 'Option "inputs" required for buttons renderer';
		}
		let inputs = opt['inputs'];
		return function(content) {
			let element = document.createElement('div');
			element.classList.add('input');
			element.classList.add('buttons')
			
			for (let i = 0; i < inputs.length ; i++) {
				let inputElement = document.createElement('input');
				inputElement.type = 'button';
				inputElement.value = inputs[i];
				if (inputElement.value == content) {
					inputElement.classList.add('selected');
				}
				element.appendChild(inputElement);
			}
			attachHandler(element, 'click', 'input[type="button"]', function(event){
				let oldElement = this.closest('.buttons').getElementsByClassName('selected');
				if (oldElement.length>0) {
					for( let el of oldElement) {
						el.classList.remove('selected');
					}
					oldElement = oldElement[0] ?? null;
				}
				this.classList.add('selected');
				if (this != oldElement) {
					this.closest('.'+ListingPanelController.DEFAULT_CLASS).dispatchEvent(new Event('change'));
				}
			});
			
			ListingPanelController._applyGenericRendererOptions(element, opt);
			
			return element;
		}
	}
}
class NumberUtils {

	static isNumeric(value) {
		return !isNaN(value*1);
	}

}

function barPlot(plotDivName, data, timeframe, properties, colors, titles, layout) {

	var bardata = [];

	for (let i = 1; i < properties.length; i++) {

		let trace = {
			x: [],
			y: [],
			marker: {
				color: []
			},
			name: [],
			type: 'bar'
		}

		let property = properties[i];

		trace.x.push(titles[property]);
		trace.y.push(data[property][timeframe]);

		trace.marker.color.push("rgba(" + colors[property].join(",") + ")");
		trace.name = titles[property];

		bardata.push(trace);
	}



	var layout = {
		showlegend: true,
	};

	Plotly.newPlot(plotDivName, bardata, layout);
}

function volumeStackedPlot(plotDivName, data, properties, colors, titles, layout, percentual = false) {

	var traces = [];
	for (let i = 1; i < properties.length; i++) {
		series = {};

		series.x = [];
		series.y = [];

		if (titles != null && titles[properties[i]] != null) {
			series.name = titles[properties[i]];
		}
		series.stackgroup = 'one';
		if (percentual) {
			series.groupnorm = 'percent';
		}
		series.fillcolor = "rgba(" + colors[properties[i]].join(",") + ")";

		for (let t = 0; t < data[properties[i]].length; t++) {
			series.x.push(data[properties[0]][t]);
			series.y.push(data[properties[i]][t]);
		}

		traces.push(series);
	}

	if (layout == undefined) {
		layout = {};
	}
	if (layout.title == undefined) {
		layout.title = {
			text: percentual ? 'Percentual Volume Stack' : 'Volume Stack'
		}
	}

	Plotly.newPlot(plotDivName, traces, layout)
}





function sankeyPlot(
	plotDivName,
	links,
	timeframe,
	properties,
	titles,
	layout,
	colors = null,
	positionsX = null,
	positionsY = null
) {

	let link = getLink(links, timeframe);

	//labels bepalen
	labels = [];
	for (var i = 0; i < properties.length; i++) {
		labels.push(titles[properties[i]]);
	}

	let node = {
		pad: 15,
		thickness: 20,
		line: { color: "black", width: 0.5 },
		label: labels,
		align: "right"
	};

	// Voeg optionele kleuren toe
	if (colors !== null) {
		node.color = properties.map(p => colors[p]);
	}

	// Voeg optionele posities toe
	if (positionsX !== null && positionsY !== null) {
		node.x = properties.map(p => positionsX[p]);
		node.y = properties.map(p => positionsY[p]);
	}

	// Maak het Sankey data object
	let data = {
		type: "sankey",
		orientation: "h",
		node: node,
		link: link
	};



	Plotly.newPlot(plotDivName, [data], layout);
}

function createRadarPlot(plotDivName, labels, values, range, layout) {

	if (Array.isArray(values)) {
		console.error('Array provided for Radarplot rather than mapping. Placing values in mapping under key "Values".');
		values = { 'Values': values };
	}

	let plotLabels = labels.slice(0, labels.length);
	plotLabels.push(labels[0]);

	let plotData = [];
	for (let i in values) {

		let plotValues = [];
		for (let l = 0; l < labels.length; l++) {
			plotValues[l] = values[i][l] ?? 0;
		}

		plotValues.push(plotValues[0]);

		plotData.push({
			type: 'scatterpolar',
			r: plotValues,
			theta: plotLabels,
			fill: 'toself',
			name: i,
			showlegend: true,
		});
	}

	let plotLayout = JSON.parse(JSON.stringify(layout)); //deep copy
	
	plotLayout['polar'] ??= {
		radialaxis: {
			visible: true,
			direction: 'clockwise',
			range: [Math.min.apply(null, range), Math.max.apply(null, range)]
		},
		angularaxis: {
			direction: 'clockwise'
		},
	};

	Plotly.newPlot(plotDivName, plotData, plotLayout);

}

function createPiePlot(plotDivName, labels, values, layout) {
	if (!Array.isArray(values)) {
		throw new Error('PiePlot requires an array of values. Provided was: ' + (typeof values));
	}

	let plotLabels = labels;
	let plotValues = values;

	let plotData = [{
		'labels': plotLabels,
		'values': plotValues,
		'type': 'pie',
		'sort': false
	}];

	let plotLayout = layout;

	Plotly.newPlot(plotDivName, plotData, plotLayout);

}

function createLayout() {
	/**
	 * See https://plotly.com/javascript/reference/layout/
	 */

	const layout = {
		title: {
			automargin: undefined,
			font: undefined, /*{color, family, lineposition,shadow, size style, textcase, variant, weight}*/
			pad: undefined,  /*b, l ,r ,t*/
			subtitle: undefined, /*{
						font: undefined, 
						text: undefined		
						x: undefined,
						xanchor: undefined,
						xref: undefined,
						y: undefined, 
						yanchor: undefined, 
						yref: undefined,}*/

			text: undefined,
			x: undefined,
			xanchor: undefined,
			xref: undefined,
			y: undefined,
			yanchor: undefined,
			yref: undefined,
		},
		showLegend: undefined,

		legend: {
			bgcolor: undefined,
			bordercolor: undefined,
			borderwidth: undefined,
			entrywidth: undefined,
			entrywidthmode: undefined,
			font: undefined,
			groupclick: undefined,
			grouptitlefont: undefined,
			indentation: undefined,
			itemclick: undefined,
			itemdoubleclick: undefined,
			itemsizing: undefined,
		}, //etc

		xaxis: {

			title: {

				text: '',

				font: {

				}

			},

		},

		yaxis: {

			title: {

				text: '',

				font: {

				}

			}

		}
	};
	return layout;
}

function createVolumePlotLayout() {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	return layout;
}

function createBarPlotLayout(title) {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	layout.title.text = title;
	return layout;
}

function createSankeyPlotLayout() {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	return layout;
}

function createRadarPlotLayout() {
	const layout = createLayout();
	layout['legend'] ??= {};
	layout['margin'] ??= {};

	Object.assign(layout['margin'], {
		t: 32,
		b: 32,
		l: 48,
		r: 48,
		pad: 0,
		autoexpand: true,
	});
	layout['showlegend'] ??= true;
	layout['autosize'] ??= true;

	return layout;
}

function createPiePlotLayout() {
	const layout = createLayout();
	/**
	 * Override specific settings
	 */
	return layout;
}



class QueryDataManager {

	constructor(args = {}) {
		args = Object.assign({
			allowFallbackData: true,
			sizedKeys: {}
		}, args);

		this.setAllowFallbackData(args['allowFallbackData']);
		for (let key in args['sizedKeys']) {
			this.setSizedKey(key, args['sizedKeys'][key]);
		}
	}

	allowFallbackData = true;

	sizedKeys = {};
	queryDataObjects = {};

	addQueryData(key, args = {}) {
		args = Object.assign({
			query: null,
			fallbackData: null,
			x: null,
			y: null,
		}, args);

		let queryData = new this.constructor.QueryDataObject(args);
		this.queryDataObjects[key] = queryData;

		return queryData;
	}

	addQuery(key, query) {
		return this.addQueryData(key, { query: query });
	}

	addQueryDatas(queries = {}) {
		for (let queryKey in queries) {
			this.addQueryData(queryKey, queries[queryKey]);
		}
	}

	hasData(key) {
		return (!!this.queryDataObjects[key]);
	}

	getData(key, forceToArray = true) {
		let queryDataObject = this.getQueryDataObject(key);
		let data = queryDataObject.getData(this.allowFallbackData);
		return forceToArray ? ArrayUtils.coerceToArray(data) : data;
	}

	getDataMatrix(key, outerArrayKey = null, innerArrayKey = null) {
		let data = this._getDataMatrixUnbounded(key, outerArrayKey, innerArrayKey);

		let innerSize = this.sizedKeys[innerArrayKey];
		let outerSize = this.sizedKeys[outerArrayKey];

		if (((innerSize ?? null) != null) || ((outerSize ?? null) != null)) {
			data = ArrayUtils.clampMatrixSize(data, 0, outerSize, outerSize, innerSize, innerSize);
		}

		return data;
	}

	getDataKeyValues(key, kvIndex) {
		let queryDataObject = this.getQueryDataObject(key);

		if (queryDataObject.hasNoDimensions()) {
			throw new RangeError('Cannot request key-value mapping from dimensionless data registered by key ' + key);
		}

		let data = this.getDataMatrix(key, null, kvIndex);
		data = ArrayUtils.mapFromKeyValueMatrix(data);
		if (queryDataObject.getDimensionCount() == 1) {
			return ArrayUtils.unArrayIfSingleElement(data);
		}
		return data;
	}

	getDataKeyIndexed(key, kvIndex, indexKeys) {
		let data = this.getDataMatrix(key, kvIndex);

		if (ArrayUtils.isMatrix(indexKeys)) {
			throw new TypeError('Cannot index data by matrix');
		}

		if (Array.isArray(indexKeys) && !Array.isArray(data)) {
			throw new TypeError('Cannot index singular data by array');
		}
		if (!Array.isArray(indexKeys)) {
			if (this.hasData(indexKeys)) {
				return this.getDataKeyIndexed(key, kvIndex, this.getData(indexKeys));
				
			}
			let result = {};
			result[indexKeys] = data;
			return result;
		}

		let map = {};
		for (let i = 0; i < Math.min(data.length, indexKeys.length); i++) {
			map[indexKeys[i]] = data[i];
		}
		return map;
	}

	_getDataMatrixUnbounded(key, outerArrayKey = null, innerArrayKey = null) {
		//x in query is inner , y in query is outer
		let queryDataObject = this.getQueryDataObject(key);

		//Dimensionless		
		if (!outerArrayKey && !innerArrayKey) {
			if (queryDataObject.hasNoDimensions()) {
				return queryDataObject.getData(this.allowFallbackData);
			}
			if (queryDataObject.getDimensionCount() > 1) {
				throw new RangeError('No dimension(s) defined while requesting data by key ' + key);
			}
		//Undefined dimensions
		} else if (outerArrayKey == innerArrayKey) {
			throw new RangeError('Cannot request duplicate dimension ' + outerArrayKey + ' for data registered by key ' + key)
		}

		if (outerArrayKey && (!queryDataObject.hasDimension(outerArrayKey))) {
			throw new RangeError('Dimension ' + outerArrayKey + ' not known for data registered by key ' + key);
		}
		if (innerArrayKey && (!queryDataObject.hasDimension(innerArrayKey))) {
			throw new RangeError('Dimension ' + innerArrayKey + ' not known for data registered by key ' + key);
		}

		// 2 Dimensions
		if (queryDataObject.hasDimensionX() && queryDataObject.hasDimensionY()) {
			if (innerArrayKey == queryDataObject.getDimensionX() || outerArrayKey == queryDataObject.getDimensionY()) {
				return queryDataObject.getData(this.allowFallbackData);
			} else {
				return ArrayUtils.flipMatrix(queryDataObject.getData(this.allowFallbackData));
			}
		}

		// X dimension
		else if (queryDataObject.hasDimensionX()) {
			if (innerArrayKey == queryDataObject.getDimensionX()) {
				return [queryDataObject.getData(this.allowFallbackData)];
			} else if (outerArrayKey === null || outerArrayKey == queryDataObject.getDimensionX()) {
				return queryDataObject.getData(this.allowFallbackData);
			}

		}

		//Y dimension
		else if (queryDataObject.hasDimensionY()) {
			if (innerArrayKey == queryDataObject.getDimensionY()) {
				return ArrayUtils.flipMatrix(queryDataObject.getData(this.allowFallbackData));
			} else if (outerArrayKey === null || outerArrayKey == queryDataObject.getDimensionY()) {
				let data = ArrayUtils.coerceToArray(queryDataObject.getData(this.allowFallbackData))
				return [].concat(...data);
			}

		}

		//Undefined
		throw new RangeError('Unknown state occured while requesting data of key ' + key + ' with dimension(s) ' + outerArrayKey + ', ' + innerArrayKey);
	}

	getQueryDataObject(key) {
		let queryDataObject = this.queryDataObjects[key];
		if (!queryDataObject) {
			throw new RangeError('No QueryData registered with key ' + key);
		}
		return queryDataObject;
	}
	
	getUnresolvedDataKeys() {
		let unresolved = [];
		for (let key of Object.keys(this.queryDataObjects)) {
			if (!this.getQueryDataObject(key).isAllQueryDataResolved()) {
				unresolved.push(key);
			}

		}
		return unresolved;
	}

	setAllowFallbackData(allow) {
		this.allowFallbackData = (!!allow);
	}

	setSizedKey(key, size) {
		if (size === null) {
			delete this.sizedKeys[key];
		} else {
			this.sizedKeys[key] = size;
		}
	}

	allQueriesResolved() {
		return this.getUnresolvedDataKeys().length === 0;
	}

	static isResolvedQueryData(query) {
		this.QueryDataObject.appearsResolved(query);
	}

	static {
		this.QueryDataObject = class {
			constructor(args) {
				args = Object.assign({
					query: null,
					fallbackData: null,
					x: null,
					y: null,
				}, args);

				this.setQueryData(args['query']);
				this.setFallbackData(args['fallbackData']);

				this.setDimensionX(args['x']);
				this.setDimensionY(args['y']);
			}

			queryData = null;
			fallbackData = null;
			x = null;
			y = null;

			getData(allowFallbackData = true) {
				if (this.hasResolvedQueryData()) {
					return this.getQueryData();
				}
				if (!allowFallbackData) {
					throw 'Query not resolved and no fallback data allowed';
				}

				if (this.hasResolvedFallbackData()) {
					return this.getFallbackData();
				}
				throw 'Query not resolved and no fallback data available';
			}

			getQueryData() {
				let data = this.queryData;
				data = this.constructor.copyData(data);
				if (this.hasNoDimensions()) {
					return ArrayUtils.unArrayIfSingleElement(data);
				}
				return data;
			}
			getFallbackData() {
				let data = this.fallbackData;
				data = this.constructor.copyData(data);
				if (this.hasNoDimensions()) {
					return ArrayUtils.unArrayIfSingleElement(data);
				}
				return data;
			}

			setQueryData(data) {
				this.queryData = data === null ? null : this.constructor.parseToData(data);
			}

			setFallbackData(data) {
				this.fallbackData = data === null ? null : this.constructor.parseToData(data);
			}
			setDimensionX(data) {
				this.x = data ?? null;
			}
			setDimensionY(data) {
				this.y = data ?? null;
			}

			getDimensionX() {
				return this.x;
			}
			getDimensionY() {
				return this.y;
			}
			getDimensionCount() {
				return this.getDimensionX() + this.getDimensionY();
			}

			hasDimensionX() {
				return this.x !== null;
			}

			hasDimensionY() {
				return this.y !== null;
			}
			hasDimension(dimension) {
				if (this.hasDimensionX() && this.getDimensionX() == dimension) {
					return true;
				}
				if (this.hasDimensionY() && this.getDimensionY() == dimension) {
					return true;
				}
				return false
			}
			hasNoDimensions() {
				return this.getDimensionCount() == 0;
			}

			hasQueryData() {
				return this.constructor.exists(this.queryData);
			}
			hasResolvedQueryData() {
				return this.constructor.appearsResolved(this.queryData);
			}
			hasFallbackData() {
				return this.constructor.exists(this.fallbackData);
			}
			hasResolvedFallbackData() {
				return this.constructor.appearsResolved(this.fallbackData);
			}

			isAllQueryDataResolved() {
				if (this.hasFallbackData() && !this.hasResolvedFallbackData()) {
					return false;
				}
				if (this.hasQueryData() && !this.hasResolvedQueryData()) {
					return false;
				}
				return true;
			}

			static parseToData(value) {
				if (Array.isArray(value)) {
					//Arrays can always be considered already-processed and thus fine as-is.
					return value;
				}
				//Simple quick parse
				let parsedValue = null;
				try {
					parsedValue = JSON.parse('[' + value + ']');
				} catch (err) {
					parsedValue = value;
				}
				return parsedValue;
			}
			static copyData(data) {
				//Copy data on retrieval to prevent unintended modifications to source data
				//Deep-copies required for matrix-type data, but query data is never too complex for simple JSON-method
				return JSON.parse(JSON.stringify(data));
			}

			static exists(value) {
				if (typeof value === 'undefined') {
					return false;
				}
				if (value === null) {
					return false;
				}
				return true;
			}
			static appearsResolved(value) {
				if (!this.exists(value)) {
					return false;
				}
				if (!value.indexOf) {
					//could be a number
					return true;
				}
				//split the query string, otherwise it "resolves" when used in the Tygron Platform
				return !(value.indexOf('$') === 0) && (value.indexOf('SELECT_') !== 1);
			}
		};

	}
}

function getRGBAInterpolated(value, min, max, maxColor, baseColor) {

	if (baseColor == undefined) {
		baseColor = [255, 255, 255, 0.0]
	}

	let fraction = (value - min) / (max - min);
	let red = Math.round(maxColor[0] * fraction + (1 - fraction) * baseColor[0]);
	let green = Math.round(maxColor[1] * fraction + (1 - fraction) * baseColor[1]);
	let blue = Math.round(maxColor[2] * fraction + (1 - fraction) * baseColor[2]);
	let alpha = maxColor[3] * fraction;

	return "rgba(" + [red, green, blue, alpha].join(",") + ")";
}

function addHeaderRow(table, properties, titles) {
	var header = table.createTHead();
	let headerRow = header.insertRow(-1);

	for (let i = 0; i < properties.length; i++) {

		let cell = headerRow.insertCell(-1);
		cell.innerHTML = titles[properties[i]];
	}
}

function addTimeframeRow(tableBody, timeframe, data, properties, colors, timeLabels) {
	
	let row = tableBody.insertRow(-1);

	for (let n = 0; n < properties.length; n++) {

		let cell = row.insertCell(-1);

		let labelDiv = document.createElement('div');
		let label = document.createElement('label');

		if (n === 1 && timeLabels) {
			label.innerHTML = timeLabels[timeframe];

		} else {

			let value = data[properties[n]][timeframe];
			let min = Math.min.apply(Math, data[properties[n]]);
			let max = Math.max.apply(Math, data[properties[n]]);
			let color = colors[properties[n]];

			if (typeof value == 'undefined') {
				label.innerHTML = '-';
			} else if (n === 0) {
				label.innerHTML = value.toFixed();
			} else {
				label.innerHTML = value.toFixed(2);
			}

			if (min === max || color === undefined) {
				labelDiv.style.backgroundColor = 'transparent';
			} else {
				labelDiv.style.backgroundColor = getRGBAInterpolated(value, min, max, color);
			}
		}

		labelDiv.appendChild(label);
		cell.appendChild(labelDiv);
	}
}

function createTable(divName, data, properties, colors, titles, timeLabels) {

	let table = document.getElementById(divName);
	if (table == undefined) {
		console.log("Element with id: " + divName + " does not exist.");
		return;
	}

	addHeaderRow(table, properties, titles);

	let tableBody = table.createTBody();

	for (let t = 0; t < timeframes; t++) {

		addTimeframeRow(tableBody, t, data, properties, colors, timeLabels);
	}
}


function setupTimeframeSlider(timeframeSlider, timeframe, timeframes, onInput) {
	
	timeframeSlider.max = timeframes - 1;
	timeframeSlider.value = timeframe;

	if (timeframeSlider.parentElement != null) {

		let style = timeframeSlider.parentElement.style;
		
		style.setProperty('--max', timeframeSlider.max);
		style.setProperty('--min', 0);
		style.setProperty('--step', 1);
		style.setProperty('--tickEvery', 1);
		style.setProperty('--value', timeframeSlider.value);
		style.setProperty('--text-value', JSON.stringify(timeframeSlider.value))


	}
	
	timeframeSlider.oninput = function() {
		onInput();

		if (timeframeSlider.parentElement != null) {
			
			let style = timeframeSlider.parentElement.style;

			style.setProperty('--value', timeframeSlider.value);
			style.setProperty('--text-value', JSON.stringify(timeframeSlider.value))
		}
	};
}








let windowValidation = true;

if (windowValidation) {

	$(window).on("load", function() {

		if ('$SELECT_ID_WHERE_AREA_IS_ID'.indexOf('$') != -1) {
			let message = '<p>Error: Queries not loaded</p>';
			message += '<p>Please ensure:</p><ul>';
			message += '<li>This content is added to a Template Text Panel, applied to Areas.</li>';
			message += '<li>The Session has fully recalculated.</li>';
			message += '</ul>';
			let messageEl = document.createElement('div');
			messageEl.innerHTML = message;
			document.body.prepend(messageEl);
		} else {
			if ((+'$SELECT_ATTRIBUTE_WHERE_PANEL_IS_ID_AND_NAME_IS_INSTALLED') != 1) {
				let message = '<p>Install app.</p>';
				message += '<p>Note: run from web browser, or ensure REFRESH of the panel is off.</p>';
				let messageEl = document.createElement('div');
				messageEl.innerHTML = message;

				let optionsEl = document.createElement('div');
				let buttonEl = document.createElement('input');
				buttonEl.id = 'installType';
				buttonEl.type = 'button';
				buttonEl.value = 'Install';
				buttonEl.disabled = true;

				let selectEl = document.createElement('select');
				selectEl.id = 'installType';
				selectEl.innerHTML += '<option selected value="">Select Water Overlay Type</option>';
				selectEl.innerHTML += '<option value="RAINFALL">RAINFALL</option>';
				selectEl.innerHTML += '<option value="GROUNDWATER">GROUNDWATER</option>';
				selectEl.innerHTML += '<option value="FLOODING">FLOODING</option>';
				selectEl.innerHTML += '<option value="NONE">Continue without install</option>';

				optionsEl.appendChild(selectEl);
				optionsEl.appendChild(buttonEl);

				attachHandler(optionsEl, 'change', 'select', function() {
					console.log(document.getElementById('installType').value);
					buttonEl.disabled = (selectEl.value == '');
					buttonEl.value = (selectEl.value == 'NONE') ? 'Continue' : 'Install';
				});

				attachHandler(optionsEl, 'click', 'input[type="button"]', function() {

					let waterOverlayType = document.getElementById('installType').value;

					window.c = connector('$SELECT_TOKEN_WHERE_'.replaceAll('"', ''));

					if (waterOverlayType == 'NONE') {
						let chain = c.start();
						chain = chain
							.then(c.post('event/editorpanel/set_attribute', null, ['$SELECT_ID_WHERE_PANEL_IS_ID', 'INSTALLED', 1]))
							.then(c.recalculate(false))
							.then(function() {
								window.location.reload();
							});
						return;
					}

					let requiredResultChildren = [
						'BUILDING_LAST_STORAGE',
						'RAIN',
						'GROUND_LAST_STORAGE',
						'GROUND_BOTTOM_FLOW',
						'GROUND_TRANSPIRATION',
						'SEWER_LAST_VALUE',
						'EVAPOTRANSPIRATION',
						'BASE_TYPES',
						'GROUND_LAST_UNSATURATED_STORAGE'
					];

					let requiredCombos = [
						['M3WATER', 'BASE_TYPES', 'SURFACE_LAST_VALUE',
							'SWITCH(AT, 0, 0, 0, 1, 0, 2, BT, 3, BT, 4, 0, 5, BT, 6, BT, 7, BT, 8, 0, 9, BT, 10, 0, 11, BT, 12, BT, 13, 0, 14, 0, 15, BT, 16, BT, 17, 0, 18, 0)'],
						['RAIN_WATER', 'BASE_TYPES', 'RAIN',
							'SWITCH(AT, 0, 0, 0, 1, 0, 2, BT, 3, BT, 4, 0, 5, BT, 6, BT, 7, BT, 8, 0, 9, BT, 10, 0, 11, BT, 12, BT, 13, 0, 14, 0, 15, BT, 16, BT, 17, 0, 18, 0)'],
						['RAIN_LAND', 'BASE_TYPES', 'RAIN',
							'SWITCH(AT, 0, 0, BT, 1, BT, 2, 0, 3, 0, 4, BT, 5, 0, 6, 0, 7, 0, 8, BT, 9, 0, 10, BT, 11, 0, 12, 0, 13, BT, 14, BT, 15, 0, 16, 0, 17, BT, 18, BT)'],
						['EVAPOTRANSPIRATIONWATER', 'BASE_TYPES', 'EVAPOTRANSPIRATION',
							'SWITCH(AT, 0, 0, 0, 1, 0, 2, BT, 3, BT, 4, 0, 5, BT, 6, BT, 7, BT, 8, 0, 9, BT, 10, 0, 11, BT, 12, BT, 13, 0, 14, 0, 15, BT, 16, BT, 17, 0, 18, 0)'],
						['EVAPOTRANSPIRATIONLAND', 'BASE_TYPES', 'EVAPOTRANSPIRATION',
							'SWITCH(AT, 0, 0, BT, 1, BT, 2, 0, 3, 0, 4, BT, 5, 0, 6, 0, 7, 0, 8, BT, 9, 0, 10, BT, 11, 0, 12, 0, 13, BT, 14, BT, 15, 0, 16, 0, 17, BT, 18, BT)'],
					]


					c = window.c;

					let chain = c.start();
					let scriptVars = {};

					//	WATERAREA AANMAKEN
					chain = chain
						.then(c.post('event/editorarea/generate_water_areas', null, [10]))
						;

					chain = chain
						.then(c.post('event/editoroverlay/add', null, [waterOverlayType]))
						.then(c.chain(function(data) {
							scriptVars['mainOverlayId'] = data;
							scriptVars['SURFACE_LAST_VALUE_ID'] = data;
						}))
						.then(c.post('event/editoroverlay/set_result_type', null, [-1, 'SURFACE_LAST_VALUE'], function(d, u, qp, params) {
							params[0] = scriptVars['SURFACE_LAST_VALUE_ID'];
						}))
						.then(c.post('event/editoroverlay/set_attribute', null, [-1, 'GROUND_WATER', 1], function(d, u, qp, params) {
							params[0] = scriptVars['SURFACE_LAST_VALUE_ID'];
						}))

						;
					for (let type of requiredResultChildren) {
						chain = chain.then(
							c.post('event/editoroverlay/add_result_child', null, [-1, type], function(d, u, qp, params) {
								params[0] = scriptVars['mainOverlayId'];
							}));
						chain = chain.then(
							c.chain(function(data, type) {
								scriptVars[type + '_ID'] = data;
							}, type)
						);
					}

					for (let settings of requiredCombos) {
						chain = chain
							.then(c.post('event/editoroverlay/add', null, ['COMBO']))
							.then(c.chain(function(data) {
								scriptVars['comboId'] = data;
							}))
							.then(c.post('event/editoroverlay/set_name', null, [-1, 'Unnamed Combo'], function(d, u, qp, params) {
								params[0] = scriptVars['comboId'];
								params[1] = settings[0];
							}))
							.then(c.post('event/editoroverlay/set_prequel', null, [-1, -1, 'A'], function(d, u, qp, params) {
								params[0] = scriptVars['comboId'];
								params[1] = scriptVars[settings[1] + '_ID'];
							}))
							.then(c.post('event/editoroverlay/set_prequel', null, [-1, -1, 'B'], function(d, u, qp, params) {
								params[0] = scriptVars['comboId'];
								params[1] = scriptVars[settings[2] + '_ID'];
							}))
							.then(c.post('event/editoroverlay/set_combo_formula', null, [-1, 'ADD(1,2)'], function(d, u, qp, params) {
								params[0] = scriptVars['comboId'];
								params[1] = settings[3];
							}))
							.then(c.post('event/editoroverlay/set_attribute', null, [-1, 'M3WATER', 1], function(d, u, qp, params) {
								params[0] = scriptVars['comboId'];
								params[1] = settings[0];
							}))
					}

					chain = chain
						.then(c.recalculate(true))
						.then(c.post('event/editorpanel/set_attribute', null, ['$SELECT_ID_WHERE_PANEL_IS_ID', 'INSTALLED', 1]))
						.then(c.recalculate(false))
						.then(function() {
							window.location.reload();
						})
						;
				});
				document.body.innerHTML = '';
				document.body.appendChild(messageEl);
				document.body.appendChild(optionsEl);
			}

		}
	});
}

const M3TOTAL = 'm3Total';
const M3LAND = 'm3Land';
const M3WATER = 'm3Water';
const M3SEWER = 'm3Sewer';
const M3UNSATURATED = 'm3Unsaturated';
const M3SATURATED = 'm3Saturated';
const M3STORAGE = 'm3Storage';
const M3GROUND = 'm3Ground';
const TIMEFRAMES = 'timeframes';
const TIMEFRAMETIMES = 'timeframetimes';

const data = {};
data[TIMEFRAMETIMES] = [$SELECT_NAME_WHERE_TIMEFRAME_IS_X_AND_RESULTTYPE_IS_SURFACE_LAST_VALUE];
data[M3TOTAL] = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_SURFACE_LAST_VALUE_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
data[M3WATER] = [$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_M3WATER_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
data[M3GROUND] = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_GROUND_LAST_STORAGE_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
data[M3STORAGE] = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_BUILDING_LAST_STORAGE_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
data[M3SEWER] = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_SEWER_LAST_VALUE_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
data[M3UNSATURATED] = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_GROUND_LAST_UNSATURATED_STORAGE_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
data[M3SATURATED] = data[M3GROUND].map((value, index) => {
	return value - data[M3UNSATURATED][index];
});
data[M3LAND] = [];
data[TIMEFRAMES] = [];

const timeframes = data[TIMEFRAMETIMES].length;
var timeframe = timeframes - 1;

for (var i = 0; i < data[M3TOTAL].length && i < data[M3WATER].length; i++)
	data[M3LAND].push(data[M3TOTAL][i] - data[M3WATER][i]);

for (var i = 0; i < timeframes; i++)
	data[TIMEFRAMES].push(i);

let timeLabels = data[TIMEFRAMETIMES];
const properties = [TIMEFRAMES, TIMEFRAMETIMES, M3LAND, M3WATER, M3SATURATED, M3UNSATURATED, M3SEWER, M3STORAGE];
const plotProperties = [TIMEFRAMES, M3LAND, M3WATER, M3SATURATED, M3UNSATURATED, M3SEWER, M3STORAGE];


const titles = {};
titles[TIMEFRAMES] = "Timeframes";
titles[TIMEFRAMETIMES] = "Tijdstap";
titles[M3LAND] = "Water op land [m]";
titles[M3WATER] = "Oppervlaktewater [m]";
titles[M3GROUND] = "Grondwater [m]";
titles[M3STORAGE] = "Waterbergende voorzieningen [m]";
titles[M3SEWER] = "Rioolwater [m]";
titles[M3UNSATURATED] = "Berging onverzadidge zone [m]"
titles[M3SATURATED] = "Berging verzadidge zone [m]"

const colors = {};
colors[M3WATER] = [10, 10, 218, 0.5];
colors[M3LAND] = [10, 218, 10, 0.5];
colors[M3GROUND] = [165, 42, 42, 0.5];
colors[M3STORAGE] = [218, 10, 10, 0.5];
colors[M3SEWER] = [128, 128, 128, 0.5];
colors[M3UNSATURATED] = [218, 165, 10, 0.5];
colors[M3SATURATED] = [10, 165, 165, 0.5];



createTable("waterBalanceTable", data, properties, colors, titles, timeLabels);

const barPlotLayout = createBarPlotLayout();
barPlotLayout.title.text = "Berging per component";
barPlotLayout.yaxis.title.text = "Volume [m]";
barPlotLayout.xaxis.title.text = "Component";

const barSlider = document.getElementById("barSlider");
barPlot("balancePlot", data, barSlider.value, plotProperties, colors, titles, barPlotLayout);
setupTimeframeSlider(barSlider, timeframe, timeframes, function() {
	barPlot("balancePlot", data, barSlider.value, plotProperties, colors, titles, barPlotLayout);
});

const MODEL_IN = 'MODEL_IN';
const MODEL_OUT = 'MODEL_OUT';
const RAINM3 = 'RAINM3';
const RAINM3LAND = 'RAINM3LAND';
const RAINM3WATER = 'RAINM3WATER';
const RAINM3STORAGE = 'RAINM3STORAGE';

const LANDSEWER = 'LANDSEWER';


const EVAPOTRANSPIRATION = 'EVAPOTRANSPIRATION';
const GROUND_TRANSPIRATION = 'GROUND_TRANSPIRATION';
const SURFACE_EVAPORATIONLAND = 'SURFACE_EVAPORATIONLAND';
const SURFACE_EVAPORATIONWATER = 'SURFACE_EVAPORATIONWATER';

const SEWER_POC = 'sewer_POC';
const SEWER_OVERFLOW_OUT = 'SEWER_OVERFLOW_OUT';

const INLET_SURFACE = 'INLET_SURFACE';
const INLET_GROUND = 'INLET_GROUND';
const OUTLET_SURFACE = "OUTLET_SURFACE";
const OUTLET_GROUND = "OUTLET_GROUND";
const BOTTOM_FLOW_IN = "BOTTOM_FLOW_IN";
const BOTTOM_FLOW_OUT = "BOTTOM_FLOW_OUT";
const CULVERT = "CULVERT";
const CULVERT_IN = "CULVERT_IN";
const CULVERT_OUT = "CULVERT_OUT";
const CULVERT_INNER = "CULVERT_INNER";
const PUMP = "PUMP";
const PUMP_IN = "PUMP_IN";
const PUMP_OUT = "PUMP_OUT";
const PUMP_INNER = "PUMP_INNER";
const WEIR = "WEIR";
const WEIR_IN = "WEIR_IN";
const WEIR_OUT = "WEIR_OUT";
const WEIR_INNER = "WEIR_INNER";
const BREACH = "BREACH";
const BREACH_IN = "BREACH_IN";
const BREACH_OUT = "BREACH_OUT";

const flowTitles = {};
flowTitles[TIMEFRAMES] = "Timeframes";

flowTitles[RAINM3] = 'Neerslag [m/tijdstap]';
flowTitles[RAINM3LAND] = 'Neerslag op land [m/tijdstap]';
flowTitles[RAINM3WATER] = 'Neerslag op water [m/tijdstap]';
flowTitles[RAINM3STORAGE] = 'Neerslag op bergende voorzieningen [m/tijdstap]';
flowTitles[LANDSEWER] = 'Toestroom naar riool [m/tijdstap]';

flowTitles[EVAPOTRANSPIRATION] = 'Verdamping [m/tijdstap]';
flowTitles[GROUND_TRANSPIRATION] = 'Plant transpiratie [m/tijdstap]';
flowTitles[SURFACE_EVAPORATIONLAND] = 'Verdamping Land [m/tijdstap]';
flowTitles[SURFACE_EVAPORATIONWATER] = 'Verdamping Water [m/tijdstap]';


flowTitles[SEWER_POC] = 'POCRiool [m/tijdstap]';

flowTitles[SEWER_OVERFLOW_OUT] = 'Riooloverstort [m/tijdstap]';

flowTitles[INLET_SURFACE] = 'Inlaat bovengronds [m/tijdstap]';
flowTitles[INLET_GROUND] = 'Inlaat ondergronds [m/tijdstap]';
flowTitles[OUTLET_SURFACE] = "Uitlaat bovengronds [m/tijdstap]";
flowTitles[OUTLET_GROUND] = "Uitlaat ondergronds [m/tijdstap]";
flowTitles[BOTTOM_FLOW_IN] = "Kwel [m/tijdstap]";
flowTitles[BOTTOM_FLOW_OUT] = "Uitzijging [m/tijdstap]";
flowTitles[CULVERT] = "Duiker [m/tijdstap]";
flowTitles[CULVERT_IN] = "Duiker in waterbeheergebied [m/tijdstap]";
flowTitles[CULVERT_OUT] = "Duiker uit waterbeheergebied [m/tijdstap]";
flowTitles[CULVERT_INNER] = "Duiker binnen waterbeheergebied [m/tijdstap]";
flowTitles[PUMP] = "Pomp";
flowTitles[PUMP_IN] = "Pomp in waterbeheergebied [m/tijdstap]";
flowTitles[PUMP_OUT] = "Pomp uit waterbeheergebied [m/tijdstap]";
flowTitles[PUMP_INNER] = "Pomp binnen waterbeheergebied [m/tijdstap]";
flowTitles[WEIR] = "Stuw";
flowTitles[WEIR_IN] = "Stuw in [m/tijdstap]";
flowTitles[WEIR_OUT] = "Stuw uit [m/tijdstap]";
flowTitles[WEIR_INNER] = "Stuw binnen waterbeheergebied [m/tijdstap]";
flowTitles[MODEL_IN] = "Waterbeheergebied in [m/tijdstap]";
flowTitles[MODEL_OUT] = "Waterbeheergebied uit [m/tijdstap]";

flowTitles[M3GROUND] = "Grondwater [m]";
flowTitles[M3UNSATURATED] = "Onverzadigde zone [m]";
flowTitles[M3SATURATED] = "Verzadigde zone [m]";
flowTitles[M3LAND] = "Land [m]";
flowTitles[M3WATER] = "Oppervlaktewater [m]";
flowTitles[M3STORAGE] = "Berging voorzieningen [m]";
flowTitles[M3TOTAL] = "Surface [m]";
flowTitles[M3SEWER] = "Riolering [m]";
flowTitles[BREACH] = "Bres";
flowTitles[BREACH_IN] = "Bres in [m/tijdstap]";
flowTitles[BREACH_OUT] = "Bres uit [m/tijdstap]";


const flowColors = {};
// Model In/Out
flowColors[MODEL_IN] = [44, 160, 44, 0.5];           // Groen
flowColors[MODEL_OUT] = [214, 39, 40, 0.5];          // Rood

//Natuurlijlke processen
flowColors[RAINM3] = [31, 119, 180, 0.5];          // Donkerblauw - Neerslag
flowColors[RAINM3LAND] = [31, 119, 180, 0.5];          // Donkerblauw - Neerslag
flowColors[RAINM3WATER] = [31, 119, 180, 0.5];
flowColors[RAINM3STORAGE] = [31, 119, 180, 0.5];

flowColors[LANDSEWER] = [31, 119, 180, 0.5];



flowColors[EVAPOTRANSPIRATION] = [31, 119, 180, 0.5];
flowColors[GROUND_TRANSPIRATION] = [31, 119, 180, 0.5];
flowColors[SURFACE_EVAPORATIONLAND] = [31, 119, 180, 0.5];
flowColors[SURFACE_EVAPORATIONWATER] = [31, 119, 180, 0.5];


flowColors[BOTTOM_FLOW_IN] = [31, 119, 180, 0.5];
flowColors[BOTTOM_FLOW_OUT] = [31, 119, 180, 0.5];

// Berging - Lichtblauw
flowColors[M3LAND] = [196, 196, 220, 0.5];         // Berging land
flowColors[M3WATER] = [196, 196, 220, 0.5];        // Oppervlaktewater
flowColors[M3GROUND] = [196, 196, 220, 0.5];       // Bodem
flowColors[M3STORAGE] = [196, 196, 220, 0.5];      // Gebouwen
flowColors[M3UNSATURATED] = [196, 196, 220, 0.5];      // Onverzadidge zone
flowColors[M3SATURATED] = [196, 196, 220, 0.5];      // Verzadidge zone
flowColors[M3TOTAL] = [196, 196, 220, 0.5];        // Totale berging (optioneel)

// Kunstwerken - Oranje
flowColors[INLET_SURFACE] = [255, 127, 14, 0.5];
flowColors[INLET_GROUND] = [255, 127, 14, 0.5];
flowColors[OUTLET_SURFACE] = [255, 127, 14, 0.5];
flowColors[OUTLET_GROUND] = [255, 127, 14, 0.5];
flowColors[PUMP] = [255, 127, 14, 0.5];
flowColors[PUMP_IN] = [255, 127, 14, 0.5];
flowColors[PUMP_OUT] = [255, 127, 14, 0.5];
flowColors[PUMP_INNER] = [255, 127, 14, 0.5];
flowColors[SEWER_OVERFLOW_OUT] = [255, 127, 14, 0.5]; // Overstort
flowColors[SEWER_POC] = [255, 127, 14, 0.5];           // POC
flowColors[CULVERT] = [255, 127, 14, 0.5];
flowColors[CULVERT_IN] = [255, 127, 14, 0.5];
flowColors[CULVERT_OUT] = [255, 127, 14, 0.5];
flowColors[CULVERT_INNER] = [255, 127, 14, 0.5];
flowColors[WEIR] = [255, 127, 14, 0.5];
flowColors[WEIR_IN] = [255, 127, 14, 0.5];
flowColors[WEIR_OUT] = [255, 127, 14, 0.5];
flowColors[WEIR_INNER] = [255, 127, 14, 0.5];
flowColors[BREACH] = [255, 127, 14, 0.5];
flowColors[BREACH_IN] = [255, 127, 14, 0.5];
flowColors[BREACH_OUT] = [255, 127, 14, 0.5];



const flowProperties = [TIMEFRAMES, MODEL_IN, MODEL_OUT, M3LAND, M3WATER, M3GROUND, M3SATURATED, M3UNSATURATED, M3STORAGE, M3SEWER, RAINM3, RAINM3LAND, RAINM3WATER, RAINM3STORAGE, GROUND_TRANSPIRATION, EVAPOTRANSPIRATION, SURFACE_EVAPORATIONLAND, SURFACE_EVAPORATIONWATER, BOTTOM_FLOW_IN, BOTTOM_FLOW_OUT, LANDSEWER, SEWER_POC, SEWER_OVERFLOW_OUT, CULVERT_IN, CULVERT_OUT, CULVERT_INNER, INLET_SURFACE, OUTLET_SURFACE, INLET_GROUND, OUTLET_GROUND, PUMP_IN, PUMP_OUT, PUMP_INNER, WEIR_IN, WEIR_OUT, WEIR_INNER, BREACH_IN, BREACH_OUT];
const flowData = createTimeframeData(timeframes, $ID, flowProperties);

const culvertAreaFrom = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_CULVERT_DIAMETER_AND_INDEX_IS_0];
const culvertAreaTo = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_CULVERT_DIAMETER_AND_INDEX_IS_1];
const pumpAreaFrom = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_PUMP_Q_AND_INDEX_IS_0];
const pumpAreaTo = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_PUMP_Q_AND_INDEX_IS_1];
const inletAreaFrom = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_INLET_Q_AND_INDEX_IS_0];
const inletAreaTo = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_INLET_Q_AND_INDEX_IS_1];
const weirAreaFrom = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_WEIR_HEIGHT_AND_INDEX_IS_0];
const weirAreaTo = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_BUILDING_IS_XA_WEIR_HEIGHT_AND_INDEX_IS_1];
const breachAreaFrom = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_AREA_IS_XA_BREACH_HEIGHT_AND_INDEX_IS_0];
const breachAreaTo = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_WATER_AREA_OUTPUT_AND_AREA_IS_XA_BREACH_HEIGHT_AND_INDEX_IS_1];
const inletUnderground = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_UNDERGROUND_AND_BUILDING_IS_XA_INLET_Q_AND_INDEX_IS_0];
const inletSurface = [];

for (let i = 0; i < inletUnderground.length; i++) {
	inletSurface.push(inletUnderground[i] <= 0);
	inletUnderground[i] = inletUnderground[i] > 0;

}

for (var i = 0; i < timeframes; i++)
	flowData[TIMEFRAMES][i] = i;

setTimeframeValues(flowData, RAINM3, [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_RAIN_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID], { relative: true });



const cumulativeValuesRain = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_RAIN_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesRain = cumulativeValuesRain.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, RAINM3, stepwiseValuesRain);

const cumulativeValuesEvaporated = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_EVAPOTRANSPIRATION_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesEvaporated = cumulativeValuesEvaporated.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, EVAPOTRANSPIRATION, stepwiseValuesEvaporated);

const rawValuesBottomFlowIn = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_GROUND_BOTTOM_FLOW_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const cumulativeValuesBottomFlowIn = rawValuesBottomFlowIn.map(val => Math.max(0, val));

const stepwiseValuesBottomFlowIn = cumulativeValuesBottomFlowIn.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});

setTimeframeValues(flowData, BOTTOM_FLOW_IN, stepwiseValuesBottomFlowIn);

const rawValuesBottomFlowOut = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_GROUND_BOTTOM_FLOW_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const cumulativeValuesBottomFlowOut = rawValuesBottomFlowOut.map(val => Math.abs(val));

const stepwiseValuesBottomFlowOut = cumulativeValuesBottomFlowOut.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});

setTimeframeValues(flowData, BOTTOM_FLOW_OUT, stepwiseValuesBottomFlowOut);

flowData[M3TOTAL] = data[M3TOTAL];
flowData[M3WATER] = data[M3WATER];
flowData[M3LAND] = data[M3LAND];
flowData[M3STORAGE] = data[M3STORAGE];
flowData[M3GROUND] = data[M3GROUND];
flowData[M3SEWER] = data[M3SEWER];
flowData[M3UNSATURATED] = data[M3UNSATURATED];
flowData[M3SATURATED] = data[M3SATURATED];

flowData[MODEL_IN] = flowData[RAINM3].map((_, i) =>
	flowData[RAINM3][i] +
	flowData[INLET_GROUND][i] +
	flowData[INLET_SURFACE][i] +
	flowData[BOTTOM_FLOW_IN][i]
);

flowData[MODEL_OUT] = flowData[EVAPOTRANSPIRATION].map((_, i) =>
	flowData[EVAPOTRANSPIRATION][i] +
	flowData[OUTLET_GROUND][i] +
	flowData[OUTLET_SURFACE][i] +
	flowData[BOTTOM_FLOW_OUT][i]
);

// Voeg duikerbijdrage toe
flowData[CULVERT_IN].forEach((_, i) => {
	const verschil = flowData[CULVERT_IN][i] - flowData[CULVERT_OUT][i];
	if (verschil > 0) {
		flowData[MODEL_IN][i] += verschil;
	} else {
		flowData[MODEL_OUT][i] += Math.abs(verschil);
	}
});

//Neerslag - Berging Land
const cumulativeValuesRainLand = [$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_RAIN_LAND_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesRainLand = cumulativeValuesRainLand.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, RAINM3LAND, stepwiseValuesRainLand);

//Neerslag - Berging Oppervlaktewater
const cumulativeValuesRainWater = [$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_RAIN_WATER_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesRainWater = cumulativeValuesRainWater.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, RAINM3WATER, stepwiseValuesRainWater);

//Neerslag - Berging Gebouwen
const cumulativeValuesRainStorage = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_BUILDING_LAST_STORAGE_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesRainStorage = cumulativeValuesRainStorage.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, RAINM3STORAGE, stepwiseValuesRainStorage);

//Berging Land - Berging riool
const cumulativeValuesSewer = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_SEWER_LAST_VALUE_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesSewer = cumulativeValuesSewer.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, LANDSEWER, stepwiseValuesSewer);

//Verdamping totaal
const cumulativeValuesEvapotranspiration = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_EVAPOTRANSPIRATION_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesEvapotranspiration = cumulativeValuesEvapotranspiration.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, EVAPOTRANSPIRATION, stepwiseValuesEvapotranspiration);

//Berging Bodem - Verdamping
const cumulativeValuesTranspiration = [$SELECT_GRIDVOLUME_WHERE_RESULTTYPE_IS_GROUND_TRANSPIRATION_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesTranspiration = cumulativeValuesTranspiration.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, GROUND_TRANSPIRATION, stepwiseValuesTranspiration);

//Verdamping Land
const cumulativeValuesEVAPORATIONLAND = [$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_EVAPORATIONLAND_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesEVAPORATIONLAND = cumulativeValuesEVAPORATIONLAND.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, SURFACE_EVAPORATIONLAND, stepwiseValuesEVAPORATIONLAND);


//Verdamping Water
const cumulativeValuesEVAPORATIONWATER = [$SELECT_GRIDVOLUME_WHERE_GRID_WITH_ATTRIBUTE_IS_EVAPORATIONWATER_AND_TIMEFRAME_IS_X_AND_AREA_IS_ID];
const stepwiseValuesEVAPORATIONWATER = cumulativeValuesEVAPORATIONWATER.map((val, index, arr) => {
	if (index === 0) return val;
	return val - arr[index - 1];
});
setTimeframeValues(flowData, SURFACE_EVAPORATIONWATER, stepwiseValuesEVAPORATIONWATER);

//Berging Land - Uitlaat/Inlaat
const landInlet = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XA_INLET_Q_AND_TIMEFRAME_IS_Y];

for (let timeframeKey = 0; timeframeKey < landInlet.length; timeframeKey++) {
	let timeframeValues = landInlet[timeframeKey];
	addFlowValues(
		flowData,
		timeframeKey,
		INLET_SURFACE,
		OUTLET_SURFACE,
		inletAreaFrom,
		inletAreaTo,
		timeframeValues,
		condition = inletSurface
	);
}

//Berging Water - bres
const waterBreach = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_AREA_IS_XA_BREACH_HEIGHT_AND_TIMEFRAME_IS_Y];

for (let timeframeKey = 0; timeframeKey < waterBreach.length; timeframeKey++) {
	let timeframeValues = waterBreach[timeframeKey];
	addFlowValuesWithInner(
		flowData,
		timeframeKey,
		BREACH_IN,
		BREACH_OUT,
		null,
		breachAreaFrom,
		breachAreaTo,
		timeframeValues,
		condition = undefined
	);
}

//Berging Water - stuw
const waterWeir = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XA_WEIR_HEIGHT_AND_TIMEFRAME_IS_Y];

for (let timeframeKey = 0; timeframeKey < waterWeir.length; timeframeKey++) {
	let timeframeValues = waterWeir[timeframeKey];
	addFlowValuesWithInner(
		flowData,
		timeframeKey,
		WEIR_IN,
		WEIR_OUT,
		WEIR_INNER,
		weirAreaFrom,
		weirAreaTo,
		timeframeValues,
		condition = undefined
	);
}

//Berging Water - Duiker
const waterCulvert = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XA_CULVERT_DIAMETER_AND_TIMEFRAME_IS_Y];

for (let timeframeKey = 0; timeframeKey < waterCulvert.length; timeframeKey++) {
	let timeframeValues = waterCulvert[timeframeKey];
	addFlowValuesWithInner(
		flowData,
		timeframeKey,
		CULVERT_IN,
		CULVERT_OUT,
		CULVERT_INNER,
		culvertAreaFrom,
		culvertAreaTo,
		timeframeValues,
		condition = undefined
	);
}

//Berging Water - Pomp
const waterPump = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XA_PUMP_Q_AND_TIMEFRAME_IS_Y];


for (let timeframeKey = 0; timeframeKey < waterPump.length; timeframeKey++) {
	let timeframeValues = waterPump[timeframeKey];
	addFlowValuesWithInner(
		flowData,
		timeframeKey,
		PUMP_IN,
		PUMP_OUT,
		PUMP_INNER,
		pumpAreaFrom,
		pumpAreaTo,
		timeframeValues,
		condition = undefined
	);
}

//Berging Bodem - Uitlaat/Inlaat
const inletGround = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XA_INLET_Q_AND_TIMEFRAME_IS_Y];


for (let timeframeKey = 0; timeframeKey < inletGround.length; timeframeKey++) {
	let timeframeValues = inletGround[timeframeKey];
	addFlowValues(
		flowData,
		timeframeKey,
		INLET_GROUND,
		OUTLET_GROUND,
		inletAreaFrom,
		inletAreaTo,
		timeframeValues,
		condition = inletUnderground
	);
}


//Berging Riool - POC
const sewerPOC = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_AREA_IS_XA_SEWER_STORAGE_AND_TIMEFRAME_IS_Y];

let sewerPOCSums = [];

for (let areaKey = 0; areaKey < sewerPOC.length; areaKey++) {
	let areaValues = sewerPOC[areaKey];
	for (let timeframeKey = 0; timeframeKey < areaValues.length; timeframeKey++) {
		sewerPOCSums[timeframeKey] = sewerPOCSums[timeframeKey] ?? 0;
		sewerPOCSums[timeframeKey] = sewerPOCSums[timeframeKey] + areaValues[timeframeKey];
	}
}

flowData[SEWER_POC] = sewerPOCSums;


//Berging Riool - Berging Land
const sewerOverflow = [$SELECT_ATTRIBUTE_WHERE_NAME_IS_OBJECT_FLOW_OUTPUT_AND_BUILDING_IS_XA_SEWER_OVERFLOW_AND_TIMEFRAME_IS_Y];

let sewerOverflowSums = [];

for (let buildingKey = 0; buildingKey < sewerOverflow.length; buildingKey++) {
	let buildingValues = sewerOverflow[buildingKey];
	for (let timeframeKey = 0; timeframeKey < buildingValues.length; timeframeKey++) {
		sewerOverflowSums[timeframeKey] = sewerOverflowSums[timeframeKey] ?? 0;
		sewerOverflowSums[timeframeKey] = sewerOverflowSums[timeframeKey] + buildingValues[timeframeKey];
	}
}

flowData[SEWER_OVERFLOW_OUT] = sewerOverflowSums;


createTable("waterFlowTable", flowData, flowProperties, flowColors, flowTitles);


const sankeyproperties = [TIMEFRAMES, MODEL_IN, MODEL_OUT, M3LAND, M3WATER, M3GROUND, M3SATURATED, M3UNSATURATED, M3STORAGE, M3SEWER, RAINM3, RAINM3LAND, RAINM3WATER, RAINM3STORAGE, GROUND_TRANSPIRATION, EVAPOTRANSPIRATION, SURFACE_EVAPORATIONLAND, SURFACE_EVAPORATIONWATER, BOTTOM_FLOW_IN, BOTTOM_FLOW_OUT, LANDSEWER, SEWER_POC, SEWER_OVERFLOW_OUT, CULVERT, CULVERT_IN, CULVERT_OUT, CULVERT_INNER, INLET_SURFACE, OUTLET_SURFACE, INLET_GROUND, OUTLET_GROUND, PUMP, PUMP_IN, PUMP_OUT, PUMP_INNER, WEIR, WEIR_IN, WEIR_OUT, WEIR_INNER, BREACH, BREACH_IN, BREACH_OUT];

let links = createLinks(sankeyproperties);
for (let i = 0; i < timeframes; i++) {
	//Model in
	addLink(links, i, MODEL_IN, RAINM3, flowData[RAINM3][i]);
	addLink(links, i, MODEL_IN, INLET_GROUND, flowData[INLET_GROUND][i]);
	addLink(links, i, MODEL_IN, INLET_SURFACE, flowData[INLET_SURFACE][i]);
	addLink(links, i, MODEL_IN, BOTTOM_FLOW_IN, flowData[BOTTOM_FLOW_IN][i]);
	addLink(links, i, MODEL_IN, CULVERT, flowData[CULVERT_IN][i]);
	addLink(links, i, MODEL_IN, PUMP, flowData[PUMP_IN][i]);
	addLink(links, i, MODEL_IN, WEIR, flowData[WEIR_IN][i]);
	addLink(links, i, MODEL_IN, BREACH, flowData[BREACH_IN][i]);

	//Neerslag	
	addLink(links, i, RAINM3, M3LAND, flowData[RAINM3LAND][i]);
	addLink(links, i, RAINM3, M3WATER, flowData[RAINM3WATER][i]);
	addLink(links, i, RAINM3, M3STORAGE, flowData[RAINM3STORAGE][i]);

	//Berging Land
	addLink(links, i, M3LAND, M3SEWER, flowData[LANDSEWER][i]);
	addLink(links, i, M3LAND, EVAPOTRANSPIRATION, flowData[SURFACE_EVAPORATIONLAND][i]);
	//addLink(links, i, M3LAND, M3GROUND, flowData[][i]);

	//Berging oppervlaktewater
	//addLink(links, i, M3WATER, M3GROUND, flowData[][i]);
	addLink(links, i, M3WATER, WEIR, flowData[WEIR_OUT][i]);
	addLink(links, i, M3WATER, EVAPOTRANSPIRATION, flowData[SURFACE_EVAPORATIONWATER][i]);
	addLink(links, i, M3WATER, CULVERT, flowData[CULVERT_OUT][i]);
	addLink(links, i, M3WATER, OUTLET_SURFACE, flowData[OUTLET_SURFACE][i]);
	addLink(links, i, M3WATER, PUMP, flowData[PUMP_OUT][i]);
	addLink(links, i, M3WATER, PUMP, flowData[PUMP_INNER][i]);
	addLink(links, i, M3WATER, WEIR, flowData[WEIR_INNER][i]);
	addLink(links, i, M3WATER, CULVERT, flowData[CULVERT_INNER][i]);


	//Berging Bodem
	addLink(links, i, M3GROUND, BOTTOM_FLOW_OUT, flowData[BOTTOM_FLOW_OUT][i]);
	addLink(links, i, M3GROUND, GROUND_TRANSPIRATION, flowData[GROUND_TRANSPIRATION][i]);
	addLink(links, i, M3GROUND, OUTLET_GROUND, flowData[OUTLET_GROUND][i]);

	//Berging Riool
	addLink(links, i, M3SEWER, SEWER_OVERFLOW_OUT, flowData[SEWER_OVERFLOW_OUT][i]);
	addLink(links, i, M3SEWER, SEWER_POC, flowData[SEWER_POC][i]);

	//Inlaat Surface
	addLink(links, i, INLET_SURFACE, M3LAND, flowData[INLET_SURFACE][i]); // Eigenlijk zou hier een uitsplitsing moeten zijn tussen een inlaat op land en een inlaat in het water

	//Inlaat Ground
	addLink(links, i, INLET_GROUND, M3GROUND, flowData[INLET_GROUND][i]);

	//Uitlaat Surface
	addLink(links, i, OUTLET_SURFACE, MODEL_OUT, flowData[OUTLET_SURFACE][i]);

	//Uitlaat Land
	addLink(links, i, OUTLET_GROUND, MODEL_OUT, flowData[OUTLET_GROUND][i]);

	//Kwel 
	addLink(links, i, BOTTOM_FLOW_IN, M3GROUND, flowData[BOTTOM_FLOW_IN][i]);

	//Riool overstort
	addLink(links, i, SEWER_OVERFLOW_OUT, M3LAND, flowData[SEWER_OVERFLOW_OUT][i]);

	//POC
	addLink(links, i, SEWER_POC, MODEL_OUT, flowData[SEWER_POC][i]);

	//Wegzijging
	addLink(links, i, BOTTOM_FLOW_OUT, MODEL_OUT, flowData[BOTTOM_FLOW_OUT][i]);

	//Platen transpiratie
	addLink(links, i, GROUND_TRANSPIRATION, MODEL_OUT, flowData[GROUND_TRANSPIRATION][i]);

	//Stuw
	addLink(links, i, WEIR, MODEL_OUT, flowData[WEIR_OUT][i]);
	addLink(links, i, WEIR, M3WATER, flowData[WEIR_INNER][i]);

	//Duiker in
	addLink(links, i, CULVERT, M3WATER, flowData[CULVERT_IN][i]);
	addLink(links, i, CULVERT, M3WATER, flowData[CULVERT_INNER][i]);

	//Duiker uit
	addLink(links, i, CULVERT, MODEL_OUT, flowData[CULVERT_OUT][i]);

	//Pomp
	addLink(links, i, PUMP, M3WATER, flowData[PUMP_IN][i]);
	addLink(links, i, PUMP, M3WATER, flowData[PUMP_INNER][i]);

	//Bres
	addLink(links, i, BREACH, M3LAND, flowData[BREACH_IN][i]);
	addLink(links, i, M3LAND, BREACH, flowData[BREACH_OUT][i]);
	addLink(links, i, BREACH, MODEL_OUT, flowData[BREACH_OUT][i]);

	//Verdamping
	addLink(links, i, EVAPOTRANSPIRATION, MODEL_OUT, flowData[EVAPOTRANSPIRATION][i]);

	//Transpiratie
	addLink(links, i, GROUND_TRANSPIRATION, MODEL_OUT, flowData[GROUND_TRANSPIRATION][i]);

}



const nodeColors = {
	MODEL_IN: "#2ca02c",
	MODEL_OUT: "#d62728",
	M3LAND: "#6699cc",
	M3WATER: "#6699cc",
	M3GROUND: "#6699cc",
	M3STORAGE: "#6699cc",
	M3SEWER: "#6699cc",
	M3UNSATURATED: "#6699cc",
	M3SATURATED: "#6699cc",
	RAINM3: "#1f77b4",
	RAINM3LAND: "#c5b0d5",
	RAINM3WATER: "#8c564b",
	RAINM3STORAGE: "#c49c94",
	GROUND_TRANSPIRATION: "#1f77b4",
	EVAPOTRANSPIRATION: "#1f77b4",
	SURFACE_EVAPORATIONLAND: "#1f77b4",
	SURFACE_EVAPORATIONWATER: "#1f77b4",
	BOTTOM_FLOW_IN: "#1f77b4",
	BOTTOM_FLOW_OUT: "#1f77b4",
	LANDSEWER: "#17becf",
	SEWER_POC: "#ff7f0e",
	SEWER_OVERFLOW_OUT: "#ff7f0e",
	CULVERT: "#ff7f0e",
	CULVERT_IN: "#ff7f0e",
	CULVERT_OUT: "#ff7f0e",
	CULVERT_INNER: "#ff7f0e",
	INLET_SURFACE: "#ff7f0e",
	OUTLET_SURFACE: "#ff7f0e",
	INLET_GROUND: "#ff7f0e",
	OUTLET_GROUND: "#ff7f0e",
	PUMP: "#ff7f0e",
	PUMP_IN: "#ff7f0e",
	PUMP_OUT: "#ff7f0e",
	PUMP_INNER: "#ff7f0e",
	WEIR: "#ff7f0e",
	WEIR_IN: "#ff7f0e",
	WEIR_OUT: "#ff7f0e",
	WEIR_INNER: "#ff7f0e",
	BREACH: "#ff7f0e",
	BREACH_IN: "#ff7f0e",
	BREACH_OUT: "#ff7f0e"
};




const sankeyLayout = createSankeyPlotLayout();

const sankeySlider = document.getElementById("sankeySlider");

sankeyPlot(
	"sankeyPlot",         // plotDivName
	links,                // links
	sankeySlider.value,   // timeframe
	sankeyproperties,     // properties
	flowTitles,           // titles
	sankeyLayout,         // layout
	nodeColors           // kleuren als object

);

setupTimeframeSlider(sankeySlider, timeframe, timeframes, function() {
	sankeyPlot(
		"sankeyPlot",         // plotDivName
		links,                // links
		sankeySlider.value,   // timeframe
		sankeyproperties,     // properties
		flowTitles,           // titles
		sankeyLayout,         // layout
		nodeColors            // kleuren als object

	);
});

let balanceCSVButton = document.getElementById("balanceCSVButton");
let flowCSVButton = document.getElementById("flowCSVButton");

addDownloadHandler(balanceCSVButton, "waterbalance.csv", () => toCSVContent(data, properties, titles, timeframes));
addDownloadHandler(flowCSVButton, "waterflow.csv", () => toCSVContent(flowData, flowProperties, flowTitles, timeframes));

	</script>
</body>

</html>